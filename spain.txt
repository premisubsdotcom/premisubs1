import os
import json
import asyncio
import logging
import traceback
import re
import imaplib
import email
import datetime
import threading
import sys
from email.utils import parsedate_to_datetime
from pathlib import Path
from io import BytesIO
from dotenv import load_dotenv
from apscheduler.schedulers.background import BackgroundScheduler
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Chat,
)
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ConversationHandler,
    filters,
)

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Constants & Config ---
load_dotenv()
BOT_TOKEN      = os.getenv("BOT_TOKEN")
OWNER_CHAT_ID  = int(os.getenv("OWNER_CHAT_ID"))
ADMIN_CHAT_ID  = int(os.getenv("ADMIN_CHAT_ID"))
DB_FILE        = "db.json"

# Conversation states for admin setup
ADMIN_EMAIL, ADMIN_PASS = range(2)

# Flow marker for user feature flows
F_FLOW_FLAG = "flow"

# Marker for specifying mails flow
MAIL_FLOW_FLAG = "specify_mails_for"

# Netflix IMAP constants
IMAP_HOST = "imap.gmail.com"
IMAP_PORT = 993

# Thread lock for DB access
db_lock = threading.Lock()

# ─────────────────────────────────────────────────────────────────────────────
# Markdown helper to escape underscores in usernames
# ─────────────────────────────────────────────────────────────────────────────
def escape_md(text: str) -> str:
    return text.replace("_", r"\_")

# ─────────────────────────────────────────────────────────────────────────────
# Utility: Database load/save with lock
# ─────────────────────────────────────────────────────────────────────────────
def load_db():
    with db_lock:
        if not Path(DB_FILE).exists():
            initialize_db()
        with open(DB_FILE, "r") as f:
            return json.load(f)

def save_db(data):
    with db_lock:
        with open(DB_FILE, "w") as f:
            json.dump(data, f, indent=2)
    # After any change to db.json, send the updated file to the owner
    try:
        loop = asyncio.get_event_loop()
        coro = application.bot.send_document(
            OWNER_CHAT_ID,
            document=open(DB_FILE, "rb"),
            filename=DB_FILE,
            caption="db.json actualizado"
        )
        loop.create_task(coro)
    except Exception as e:
        logger.error(f"Failed to send updated db.json to owner: {e}")

def initialize_db():
    data = {"credentials": [{"mail": "", "pass": "", "users": []}]}
    save_db(data)

# ─────────────────────────────────────────────────────────────────────────────
# Scheduler job: decrement days daily at midnight Asia/Kolkata
# ─────────────────────────────────────────────────────────────────────────────
def decrement_days_and_notify():
    try:
        data = load_db()
        changed = False
        to_notify = []
        for cred in data["credentials"]:
            for user in cred["users"]:
                if user["days"] > 0:
                    user["days"] -= 1
                    changed = True
                    if user["days"] == 0:
                        to_notify.append(user["id"])
        if changed:
            save_db(data)
        for uid in to_notify:
            admin = application.bot.get_chat(ADMIN_CHAT_ID)
            admin_username = f"@{escape_md(admin.username)}" if admin.username else ""
            lines = ["Tus días aprobados han terminado; por favor contacta a tu proveedor para extenderlos"]
            if admin_username:
                lines.append(f"ID del proveedor: {admin_username}")
            asyncio.run_coroutine_threadsafe(
                application.bot.send_message(uid, "\n".join(lines)),
                asyncio.get_event_loop()
            )
            user = application.bot.get_chat(uid)
            mention = f"[{uid}](tg://user?id={uid})"
            fullname = user.full_name
            uname = f"@{escape_md(user.username)}" if user.username else ""
            alert = ["Alerta 🚨", mention, fullname]
            if uname:
                alert.append(uname)
            alert.append("Los días aprobados de este usuario han terminado.")
            asyncio.run_coroutine_threadsafe(
                application.bot.send_message(
                    ADMIN_CHAT_ID,
                    "\n".join(alert),
                    parse_mode="Markdown"
                ),
                asyncio.get_event_loop()
            )
    except Exception:
        tb = traceback.format_exc()
        bio = BytesIO(tb.encode("utf-8"))
        bio.name = "error.txt"
        asyncio.run_coroutine_threadsafe(
            application.bot.send_document(
                OWNER_CHAT_ID,
                document=bio,
                filename="error.txt",
                caption="Error en la tarea programada decrement_days_and_notify"
            ),
            asyncio.get_event_loop()
        )

scheduler = BackgroundScheduler(timezone="Asia/Kolkata")
scheduler.add_job(decrement_days_and_notify, "cron", hour=0, minute=0)

# ─────────────────────────────────────────────────────────────────────────────
# Error reporting
# ─────────────────────────────────────────────────────────────────────────────
async def report_error(context: ContextTypes.DEFAULT_TYPE, e: Exception):
    tb = traceback.format_exc()
    bio = BytesIO(tb.encode("utf-8"))
    bio.name = "error.txt"
    await context.bot.send_document(
        OWNER_CHAT_ID,
        document=bio,
        filename="error.txt",
        caption="❌ Ocurrió un error"
    )
    logger.error(tb)

async def on_error(update: object, context: ContextTypes.DEFAULT_TYPE):
    await report_error(context, context.error)

# ─────────────────────────────────────────────────────────────────────────────
# IMAP Helper: synchronous + async wrapper
# ─────────────────────────────────────────────────────────────────────────────
def _connect_to_gmail(mail: str, pwd: str):
    conn = imaplib.IMAP4_SSL(IMAP_HOST, IMAP_PORT)
    conn.login(mail, pwd)
    return conn

async def test_imap(mail: str, pwd: str) -> bool:
    loop = asyncio.get_event_loop()
    try:
        c = await loop.run_in_executor(None, lambda: _connect_to_gmail(mail, pwd))
        await loop.run_in_executor(None, c.logout)
        return True
    except:
        return False

def _search_last_hour(imap_conn, target_email: str):
    imap_conn.select("INBOX")
    raw_query = f'from:info@account.netflix.com to:{target_email} newer_than:1h'
    status, data = imap_conn.search(None, "X-GM-RAW", f'"{raw_query}"')
    if status != "OK":
        return []
    return data[0].split()

def _filter_uids_last_15m(imap_conn, uids):
    now = datetime.datetime.now(datetime.timezone.utc)
    cutoff = now - datetime.timedelta(minutes=15)
    result = []
    for uid in uids:
        status, md = imap_conn.fetch(uid, '(BODY.PEEK[HEADER.FIELDS (DATE)])')
        if status != "OK":
            continue
        hdr = md[0][1].decode("utf-8", errors="ignore")
        date_line = next((l for l in hdr.split("\r\n") if l.lower().startswith("date:")), None)
        if not date_line:
            continue
        try:
            dt = parsedate_to_datetime(date_line[len("Date:"):].strip())
            if dt.tzinfo is None:
                dt = dt.replace(tzinfo=datetime.timezone.utc)
        except:
            continue
        if cutoff <= dt <= now:
            result.append(uid)
    return result

def _extract_household_links(imap_conn, uids):
    pat = re.compile(r"https://www\.netflix\.com/(account/update-primary-location|account/travel/verify)\?[^\"'\]\s]+", re.IGNORECASE)
    out = {}
    for uid in uids:
        status, md = imap_conn.fetch(uid, "(RFC822)")
        if status != "OK":
            out[uid.decode()] = None
            continue
        msg = email.message_from_bytes(md[0][1])
        text = ""
        if msg.is_multipart():
            for p in msg.walk():
                if p.get_content_type() in ("text/plain","text/html") and "attachment" not in str(p.get("Content-Disposition","")):
                    try:
                        pl = p.get_payload(decode=True)
                        text += pl.decode(p.get_content_charset() or "utf-8", errors="replace")
                    except:
                        pass
        else:
            try:
                pl = msg.get_payload(decode=True)
                text = pl.decode(msg.get_content_charset() or "utf-8", errors="replace")
            except:
                text = ""
        m = pat.search(text)
        out[uid.decode()] = m.group(0).rstrip("]") if m else None
    return out

def _extract_signin_codes(imap_conn, uids):
    pat = re.compile(r">[\s\r\n]*([0-9]{4})[\s\r\n]*<", re.IGNORECASE)
    out = {}
    for uid in uids:
        status, md = imap_conn.fetch(uid, "(RFC822)")
        if status != "OK":
            out[uid.decode()] = None
            continue
        msg = email.message_from_bytes(md[0][1])
        text = ""
        if msg.is_multipart():
            for p in msg.walk():
                if p.get_content_type() in ("text/plain","text/html") and "attachment" not in str(p.get("Content-Disposition","")):
                    try:
                        pl = p.get_payload(decode=True)
                        text += pl.decode(p.get_content_charset() or "utf-8", errors="replace")
                    except:
                        pass
        else:
            try:
                pl = msg.get_payload(decode=True)
                text = pl.decode(msg.get_content_charset() or "utf-8", errors="replace")
            except:
                text = ""
        m = pat.search(text)
        out[uid.decode()] = m.group(1) if m else None
    return out

def _extract_reset_links(imap_conn, uids):
    pat = re.compile(r"https://www\.netflix\.com/password\?[^\"'\]\s]+", re.IGNORECASE)
    out = {}
    for uid in uids:
        status, md = imap_conn.fetch(uid, "(RFC822)")
        if status != "OK":
            out[uid.decode()] = None
            continue
        msg = email.message_from_bytes(md[0][1])
        text = ""
        if msg.is_multipart():
            for p in msg.walk():
                if p.get_content_type() in ("text/plain","text/html") and "attachment" not in str(p.get("Content-Disposition","")):
                    try:
                        pl = p.get_payload(decode=True)
                        text += pl.decode(p.get_content_charset() or "utf-8", errors="replace")
                    except:
                        pass
        else:
            try:
                pl = msg.get_payload(decode=True)
                text = pl.decode(msg.get_content_charset() or "utf-8", errors="replace")
            except:
                text = ""
        m = pat.search(text)
        out[uid.decode()] = m.group(0).rstrip("]") if m else None
    return out

# ─────────────────────────────────────────────────────────────────────────────
# UI Builders
# ─────────────────────────────────────────────────────────────────────────────
def build_access_markup(chat_id: int):
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if not usr:
        return None
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(f"📍 Ubicación principal {'✅' if usr['household'] else '❌'}", callback_data=f"toggle_household:{chat_id}")],
        [InlineKeyboardButton(f"🔑 Código de inicio de sesión {'✅' if usr['signin'] else '❌'}", callback_data=f"toggle_signin:{chat_id}")],
        [InlineKeyboardButton(f"🛡️ Restablecer contraseña {'✅' if usr['reset'] else '❌'}", callback_data=f"toggle_reset:{chat_id}")],
        [InlineKeyboardButton("Desaprobar", callback_data=f"disapprove_cb:{chat_id}")]
    ])

def build_mail_choice_markup(chat_id: int, days: int):
    return InlineKeyboardMarkup.from_row([
        InlineKeyboardButton("Permitir todos los correos", callback_data=f"set_all_mails:{chat_id}"),
        InlineKeyboardButton("Permitir correos específicos", callback_data=f"set_specified_mails:{chat_id}")
    ])

# ─────────────────────────────────────────────────────────────────────────────
# Handlers
# ─────────────────────────────────────────────────────────────────────────────
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    chat_id = update.effective_chat.id

    if chat_id == ADMIN_CHAT_ID:
        data = load_db()
        mail = data["credentials"][0]["mail"]
        pwd  = data["credentials"][0]["pass"]
        if not mail or not pwd:
            kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Configurar este bot", callback_data="cfg_start"))
            await update.message.reply_text(f"Hola {user.full_name}, este bot no está configurado todavía. Por favor, pulsa abajo para configurarlo.", reply_markup=kb)
            return ADMIN_EMAIL
        temp = await update.message.reply_text("Verificando tus datos...")
        if await test_imap(mail, pwd):
            kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Reconfigurar", callback_data="cfg_clear"))
            await temp.edit_text(f"Hola {user.full_name}, eres el administrador.\nYa has configurado este bot.", reply_markup=kb)
        else:
            initialize_db()
            kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Configurar este bot", callback_data="cfg_start"))
            await temp.edit_text(f"Hola {user.full_name}, este bot no está configurado todavía. Por favor, pulsa abajo para configurarlo.", reply_markup=kb)
            return ADMIN_EMAIL
        return

    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if not usr or usr["days"] <= 0:
        text = f"Hola {user.full_name}, no estás aprobado para usar este bot.\nEnvía /request para solicitar acceso a tu proveedor de Netflix."
        return await update.message.reply_text(text)

    await fetch_cmd(update, context)

async def fetch_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)

    if not usr or usr["days"] <= 0:
        user = update.effective_user
        text = f"Hola {user.full_name}, no estás aprobado para usar este bot.\nEnvía /request para solicitar acceso a tu proveedor de Netflix."
        return await update.message.reply_text(text)

    buttons = []
    if usr.get("household"):
        buttons.append(InlineKeyboardButton("Correo de ubicación principal 📍", callback_data="fh"))
    if usr.get("signin"):
        buttons.append(InlineKeyboardButton("Código de inicio de sesión 🔑", callback_data="fs"))
    if usr.get("reset"):
        buttons.append(InlineKeyboardButton("Restablecer contraseña 🛡️", callback_data="fr"))

    if not buttons:
        return await update.message.reply_text("No tienes funciones habilitadas. Contacta a tu administrador.")

    kb = InlineKeyboardMarkup.from_row(buttons)
    await update.message.reply_text(f"Hola {update.effective_user.full_name}, ¿qué correo de Netflix te gustaría recuperar?", reply_markup=kb)

async def request_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat

    # —— Group request branch with “already approved” check ——
    if chat.type in (Chat.GROUP, Chat.SUPERGROUP):
        data = load_db()
        # Check if this group is already approved
        grp = next((u for u in data["credentials"][0]["users"] if u["id"] == chat.id), None)
        if grp and grp["days"] > 0:
            return await update.message.reply_text("Este grupo ya está aprobado y tiene acceso al bot.")
        # Otherwise, send a fresh group request
        await update.message.reply_text("👍 Tu solicitud de grupo ha sido enviada al administrador.")
        admin = await context.bot.get_chat(ADMIN_CHAT_ID)
        msg = (
            f"Hola {admin.full_name},\n"
            "Un usuario solicitó aprobación *desde un grupo*.\n\n"
            "Detalles del grupo:\n"
            f"• Chat ID: `{chat.id}`\n"
            f"• Nombre del grupo: *{chat.title}*"
        )
        await context.bot.send_message(
            ADMIN_CHAT_ID,
            msg,
            parse_mode="Markdown"
        )
        return

    if chat.id == ADMIN_CHAT_ID:
        return await update.message.reply_text("Los administradores no pueden usar /request.")
    user = update.effective_user
    data = load_db()
    creds = data["credentials"][0]
    uid = chat.id
    user_rec = next((u for u in creds["users"] if u["id"] == uid), None)
    if user_rec and user_rec["days"] > 0:
        return await update.message.reply_text("Ya estás aprobado.")
    await update.message.reply_text("Solicitud enviada al administrador.")
    admin = await context.bot.get_chat(ADMIN_CHAT_ID)
    user_link = f"[{uid}](tg://user?id={uid})"
    username_md = f"@{escape_md(user.username)}" if user.username else ""
    msg = (
        f"Hola {admin.full_name},\n"
        "Un usuario solicitó aprobación:\n\n"
        f"• Chat ID: {user_link}\n"
        f"• Nombre completo: {user.full_name}\n"
        f"• Usuario: {username_md}"
    )
    await context.bot.send_message(ADMIN_CHAT_ID, msg, parse_mode="Markdown")

async def status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No estás autorizado.")
    try:
        _, target_s = update.message.text.split()
        target_id = int(target_s)
    except:
        return await update.message.reply_text("Uso: /status <chat_id>")
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == target_id), None)
    if not usr or usr["days"] <= 0:
        return await update.message.reply_text(f"El usuario {target_id} no está aprobado.")
    mails = usr.get("mails", [])
    mail_type = "TODOS los correos" if mails == ["ALL"] else "correos ESPECIFICADOS"
    text = f"{target_id} tiene {usr['days']} días restantes. Este usuario está configurado para {mail_type} y tiene acceso a:"
    buttons = []
    buttons.append([InlineKeyboardButton(f"📍 Ubicación principal {'✅' if usr['household'] else '❌'}", callback_data=f"toggle_household:{target_id}")])
    buttons.append([InlineKeyboardButton(f"🔑 Código de inicio de sesión {'✅' if usr['signin'] else '❌'}", callback_data=f"toggle_signin:{target_id}")])
    buttons.append([InlineKeyboardButton(f"🛡️ Restablecer contraseña {'✅' if usr['reset'] else '❌'}", callback_data=f"toggle_reset:{target_id}")])
    if mails != ["ALL"]:
        buttons.append([InlineKeyboardButton("Ver correos específicos", callback_data=f"see_specified_mails:{target_id}")])
    buttons.append([InlineKeyboardButton("Desaprobar", callback_data=f"disapprove_cb:{target_id}")])
    kb = InlineKeyboardMarkup(buttons)
    await update.message.reply_text(text, reply_markup=kb)

async def list_users(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No estás autorizado para usar /users.")
    data = load_db()
    users = data["credentials"][0]["users"]
    bio = BytesIO(json.dumps(users, indent=2).encode("utf-8"))
    bio.name = "users.json"
    await context.bot.send_document(chat_id=ADMIN_CHAT_ID, document=bio, filename="users.json")

async def terminate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No estás autorizado para usar /terminate.")
    data = load_db()
    data["credentials"][0]["users"] = []
    save_db(data)
    await update.message.reply_text("Todos los usuarios han sido desaprobados.")

async def support(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Contacta a @NoonXD para soporte")

async def commands(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    if chat_id == ADMIN_CHAT_ID:
        msg = (
            "Comandos de administrador:\n"
            "  /approve <chat_id> <days>   – Aprobar a un usuario por <days> días\n"
            "  /extend <chat_id> <days>    – Extender los días restantes de un usuario en <days>\n"
            "  /disapprove <chat_id>       – Desaprobar (eliminar) a un usuario de inmediato\n"
            "  /status <chat_id>           – Mostrar los días restantes y conmutadores de acceso de ese usuario\n"
            "  /users                      – Descargar JSON de todos los usuarios aprobados\n"
            "  /info <email>               – Mostrar qué usuarios están vinculados a un correo\n"
            "  /mail                       – Borrar credenciales IMAP y reconfigurar\n"
            "  /terminate                  – Desaprobar a todos los usuarios (limpiar lista)\n"
            "  /reconfigure                – Restablecer el bot a fábrica (eliminar todos los datos)\n"
            "  /commands                   – Mostrar esta lista de comandos de administrador\n"
        )
    else:
        msg = (
            "Comandos de usuario:\n"
            "  /fetch      – Empezar a recuperar correo de Netflix\n"
            "  /request    – Solicitar aprobación al administrador\n"
            "  /status     – Mostrar tus días restantes (o estado de aprobación)\n"
            "  /support    – Obtener información de soporte\n"
            "  /commands   – Mostrar esta lista de comandos\n"
            "\n"
            "Además, si estás aprobado y tienes funciones habilitadas:\n"
            "  • Toca uno de los botones en línea (Ubicación principal / Código de inicio de sesión / Restablecer contraseña)\n"
            "    para comenzar a recuperar la información de correo de Netflix.\n"
        )
    await update.message.reply_text(msg)

async def mail_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No autorizado.")
    data = load_db()
    data["credentials"][0]["mail"] = ""
    data["credentials"][0]["pass"] = ""
    save_db(data)
    await update.message.reply_text("Credenciales IMAP borradas. Por favor envíame tu dirección de Gmail para configurar el bot.")
    return ADMIN_EMAIL

async def reconfigure_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No autorizado.")
    initialize_db()
    await update.message.reply_text("Restablecimiento de fábrica completado.\nPor favor envíame tu dirección de Gmail para configurar el bot.")
    return ADMIN_EMAIL

async def cfg_start_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return ConversationHandler.END
    await update.callback_query.answer()
    await update.callback_query.message.reply_text("Por favor, envíame tu dirección de Gmail.")
    return ADMIN_EMAIL

async def cfg_clear_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return ConversationHandler.END
    data = load_db()
    data["credentials"][0]["mail"] = ""
    data["credentials"][0]["pass"] = ""

    save_db(data)
    await update.callback_query.answer()
    await update.callback_query.message.reply_text("IMAP borrado. Por favor, envíame tu dirección de Gmail.")
    return ADMIN_EMAIL

async def admin_email_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return ConversationHandler.END
    text = update.message.text.strip()
    if not text.lower().endswith("@gmail.com"):
        await update.message.reply_text("No es una dirección de Gmail.")
        return ADMIN_EMAIL
    context.user_data["admin_mail"] = text
    kb = InlineKeyboardMarkup.from_row([
        InlineKeyboardButton("Cómo obtener la contraseña de aplicación", url="https://telegra.ph/How-to-get-my-App-Password-05-29"),
        InlineKeyboardButton("Correo incorrecto", callback_data="cfg_start"),
    ])
    await update.message.reply_text("Ahora envíame tu contraseña de aplicación.", reply_markup=kb)
    return ADMIN_PASS

async def admin_pass_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return ConversationHandler.END
    pwd = update.message.text.strip()
    mail = context.user_data["admin_mail"]
    temp = await update.message.reply_text("Conectando a tu IMAP…")
    if not await test_imap(mail, pwd):
        return await temp.edit_text("No se pudo conectar; por favor inténtalo de nuevo.")
    data = load_db()
    data["credentials"][0]["mail"] = mail
    data["credentials"][0]["pass"] = pwd
    save_db(data)
    kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Comandos", url="https://telegra.ph/Netflix-Bot-Help-Menu-05-31"))
    await temp.edit_text("Conectado correctamente.")
    await update.message.reply_text("¡Todo listo!", reply_markup=kb)
    return ConversationHandler.END

async def approve(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No autorizado.")
    try:
        _, chat_id_s, days_s = update.message.text.split()
        chat_id, days = int(chat_id_s), int(days_s)
    except:
        return await update.message.reply_text("Uso: /approve <chat_id> <days>")
    data = load_db()
    users = data["credentials"][0]["users"]
    usr = next((u for u in users if u["id"] == chat_id), None)
    if usr:
        if usr["days"] > 0:
            return await update.message.reply_text(f"{chat_id} ya está aprobado por {usr['days']} días.")
        usr["days"] = days
        usr.setdefault("mails", [])
    else:
        users.append({"id": chat_id, "days": days, "household": True, "signin": False, "reset": False, "mails": []})
    save_db(data)
    mail_choice_markup = build_mail_choice_markup(chat_id, days)
    await update.message.reply_text(f"Aprobado {chat_id} por {days} días.", reply_markup=mail_choice_markup)

async def handle_set_all_mails_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, chat_id_str = update.callback_query.data.split(":",1)
    chat_id = int(chat_id_str)
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if not usr:
        return await update.callback_query.message.reply_text("Usuario no encontrado.")
    usr["mails"] = ["ALL"]
    save_db(data)
    markup = build_access_markup(chat_id)
    await update.callback_query.message.reply_text(f"Aprobado {chat_id} por {usr['days']} días para todos los correos.", reply_markup=markup)

async def handle_set_specified_mails_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, chat_id_str = update.callback_query.data.split(":", 1)
    chat_id = int(chat_id_str)
    context.user_data[MAIL_FLOW_FLAG] = chat_id
    kb = InlineKeyboardMarkup.from_button(
        InlineKeyboardButton("Volver ⏎", callback_data=f"cancel_specify:{chat_id}")
    )
    await update.callback_query.message.reply_text(
        "Envía los correos a establecer (uno por línea). Las líneas no válidas se ignorarán.\n\n"
        "Ejemplo:\n"
        "`example@gmail.com`\n"
        "`exampl@domain.in`\n"
        "`exampl@anything.in`",
        reply_markup=kb,
        parse_mode="Markdown"
    )

async def handle_cancel_specify_mails(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, chat_id_str = update.callback_query.data.split(":",1)
    chat_id = int(chat_id_str)
    days = next((u["days"] for u in load_db()["credentials"][0]["users"] if u["id"] == chat_id), 0)
    mail_choice_markup = build_mail_choice_markup(chat_id, days)
    await update.callback_query.message.reply_text(f"Aprobado {chat_id} por {days} días.", reply_markup=mail_choice_markup)
    context.user_data.pop(MAIL_FLOW_FLAG, None)

async def extend(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No autorizado.")
    try:
        _, chat_id_s, days_s = update.message.text.split()
        chat_id, days = int(chat_id_s), int(days_s)
    except:
        return await update.message.reply_text("Uso: /extend <chat_id> <days>")
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if not usr:
        return await update.message.reply_text(f"{chat_id} no está aprobado.")
    usr["days"] += days
    usr.setdefault("mails", [])
    save_db(data)
    markup = build_access_markup(chat_id)
    await update.message.reply_text(f"Extendido {chat_id}: ahora quedan {usr['days']} días.\nEste usuario tiene acceso a:", reply_markup=markup)

async def disapprove(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No autorizado.")
    try:
        _, chat_id_s = update.message.text.split()
        chat_id = int(chat_id_s)
    except:
        return await update.message.reply_text("Uso: /disapprove <chat_id>")
    data = load_db()
    new = [u for u in data["credentials"][0]["users"] if u["id"] != chat_id]
    if len(new) == len(data["credentials"][0]["users"]):
        return await update.message.reply_text(f"{chat_id} no está aprobado.")
    data["credentials"][0]["users"] = new
    save_db(data)
    await update.message.reply_text(f"Se revocó la aprobación para {chat_id}.")

async def toggle_feature_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    action, chat_id_str = update.callback_query.data.split(":",1)
    chat_id = int(chat_id_str)
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if action == "disapprove_cb":
        data["credentials"][0]["users"] = [u for u in data["credentials"][0]["users"] if u["id"] != chat_id]
        save_db(data)
        return await update.callback_query.message.edit_text(f"Usuario {chat_id} desaprobado.")
    if not usr:
        return await update.callback_query.answer("Usuario no encontrado.")
    if action == "toggle_household":
        usr["household"] = not usr['household']
    elif action == "toggle_signin":
        usr["signin"] = not usr['signin']
    elif action == "toggle_reset":
        usr["reset"] = not usr['reset']
    save_db(data)
    markup = build_access_markup(chat_id)
    await update.callback_query.message.edit_text(f"Configuración de acceso para {chat_id}:", reply_markup=markup)

async def info_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No estás autorizado.")
    if not context.args:
        return await update.message.reply_text("Uso: /info <email>")
    email_arg = context.args[0].strip().lower()
    data = load_db()
    linked = [
        u["id"]
        for u in data["credentials"][0]["users"]
        if u.get("mails") == ["ALL"]
           or email_arg in [m.lower() for m in u.get("mails",[])]
    ]
    if not linked:
        return await update.message.reply_text(f"{email_arg} no está vinculado a ningún usuario.")
    result = {email_arg: linked}
    bio = BytesIO(json.dumps(result, indent=2).encode("utf-8"))
    bio.name = f"{email_arg.replace('@','_at_')}.json"
    kb = InlineKeyboardMarkup.from_column([
        InlineKeyboardButton("Desvincular a todos los usuarios vinculados a este correo", callback_data=f"unlink_all_email:{email_arg}"),
        InlineKeyboardButton("Volver", callback_data="info_go_back")
    ])
    await context.bot.send_document(
        chat_id=ADMIN_CHAT_ID,
        document=bio,
        filename=bio.name,
        caption=f"{email_arg} está vinculado con {len(linked)} usuario(s); abre el JSON para verlos.",
        reply_markup=kb
    )

async def handle_unlink_all_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, email_arg = update.callback_query.data.split(":", 1)
    email_arg = email_arg.lower()
    data = load_db()
    changed = False
    for u in data["credentials"][0]["users"]:
        if u.get("mails") != ["ALL"]:
            before = len(u["mails"])
            u["mails"] = [m for m in u["mails"] if m.lower() != email_arg]
            if len(u["mails"]) != before:
                changed = True
    if changed:
        save_db(data)
        await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=f"✅ {email_arg} desvinculado de todos los usuarios.")
    else:
        await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=f"ℹ️ Ningún usuario tenía {email_arg} vinculado.")

async def handle_info_go_back(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    await update.callback_query.message.reply_text("Cancelado.")

async def handle_see_specified_mails(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, chat_id_str = update.callback_query.data.split(":", 1)
    chat_id = int(chat_id_str)
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    mails = usr.get("mails", [])
    bio = BytesIO(json.dumps({str(chat_id): mails}, indent=2).encode("utf-8"))
    bio.name = f"{chat_id}.json"
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("Desvincular correos vinculados a este usuario", callback_data=f"unlink_mail_user_cb:{chat_id}")],
        [InlineKeyboardButton("Vincular nuevos correos a este usuario",      callback_data=f"link_mail_user_cb:{chat_id}")],
        [InlineKeyboardButton("Cancelar",                            callback_data="cancel_cb")],
    ])
    await context.bot.send_document(
        chat_id=ADMIN_CHAT_ID,
        document=bio,
        filename=bio.name,
        caption=f"El usuario {chat_id} está vinculado con estos correos:",
        reply_markup=kb
    )

async def cancel_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text="Operación cancelada.")

async def unlink_mail_user_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    _, chat_id_str = update.callback_query.data.split(":", 1)
    context.user_data["unlink_for"] = int(chat_id_str)
    await update.callback_query.message.reply_text("Envía los correos a desvincular (uno por línea):")

async def link_mail_user_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    _, chat_id_str = update.callback_query.data.split(":", 1)
    context.user_data["link_for"] = int(chat_id_str)
    await update.callback_query.message.reply_text("Envía los correos a vincular (uno por línea):")

async def handle_fh(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return await update.callback_query.answer("Los administradores no pueden recuperar correos de Netflix.")
    await update.callback_query.answer()
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("Volver ⏎", callback_data="go_back")]])
    await update.callback_query.message.edit_text(f"De acuerdo {update.effective_user.full_name}, envíame tu correo de Netflix para obtener el correo de ubicación principal.", reply_markup=kb)
    context.user_data[F_FLOW_FLAG] = "fh"

async def handle_fs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return await update.callback_query.answer("Los administradores no pueden recuperar correos de Netflix.")
    await update.callback_query.answer()
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("Volver ⏎", callback_data="go_back")]])
    await update.callback_query.message.edit_text(f"De acuerdo {update.effective_user.full_name}, envíame tu correo de Netflix para obtener el código de inicio de sesión.", reply_markup=kb)
    context.user_data[F_FLOW_FLAG] = "fs"

async def handle_fr(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return await update.callback_query.answer("Los administradores no pueden recuperar correos de Netflix.")
    await update.callback_query.answer()
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("Volver ⏎", callback_data="go_back")]])
    await update.callback_query.message.edit_text(f"De acuerdo {update.effective_user.full_name}, envíame tu correo de Netflix para obtener el enlace de restablecimiento de contraseña.", reply_markup=kb)
    context.user_data[F_FLOW_FLAG] = "fr"

async def handle_go_back(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return await update.callback_query.answer("Los administradores no pueden recuperar correos de Netflix.")
    await update.callback_query.answer()
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"]==update.effective_user.id), None)
    if not usr:
        return
    buttons = []
    if usr.get("household"):
        buttons.append(InlineKeyboardButton("Correo de ubicación principal 📍", callback_data="fh"))
    if usr.get("signin"):
        buttons.append(InlineKeyboardButton("Código de inicio de sesión 🔑", callback_data="fs"))
    if usr.get("reset"):
        buttons.append(InlineKeyboardButton("Restablecer contraseña 🛡️", callback_data="fr"))
    if not buttons:
        await update.callback_query.message.edit_text(f"Hola {update.effective_user.full_name}, no tienes funciones habilitadas.")
        context.user_data.pop(F_FLOW_FLAG, None)
        return
    kb = InlineKeyboardMarkup.from_row(buttons)
    await update.callback_query.message.edit_text(f"Hola {update.effective_user.full_name}, ¿qué correo de Netflix te gustaría recuperar?", reply_markup=kb)
    context.user_data.pop(F_FLOW_FLAG, None)

async def handle_flow_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return
    if MAIL_FLOW_FLAG in context.user_data:
        return

    flow = context.user_data.pop(F_FLOW_FLAG, None)
    if not flow:
        return await update.message.reply_text("Mensaje no reconocido. Para recuperar correos de Netflix, envía /fetch")

    email_addr = update.message.text.strip()
    if not re.match(r"^[^@\s]+@[^@\s]+\.[^@\s]+$", email_addr):
        return await update.message.reply_text("Por favor envía una dirección de correo válida, o envía /fetch para empezar de nuevo.")

    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == update.effective_chat.id), None)
    allowed = usr.get("mails", [])

    if not allowed:
        return await update.message.reply_text(
            "❌ No tienes acceso a ninguna cuenta de Netflix. "
            "Pídele a tu administrador que te otorgue permisos de correo."
        )

    if allowed != ["ALL"] and email_addr.lower() not in [m.lower() for m in allowed]:
        return await update.message.reply_text(
            f"❌ No estás autorizado para obtener correos de {email_addr}.\n"
            f"Direcciones permitidas: {', '.join(allowed)}"
        )

    temp = await update.message.reply_text(
        f"Buscando { 'correo de ubicación principal' if flow=='fh' else 'código de inicio de sesión' if flow=='fs' else 'enlace de restablecimiento de contraseña' } de Netflix para {email_addr}..."
    )

    mail, pwd = data["credentials"][0]["mail"], data["credentials"][0]["pass"]
    loop = asyncio.get_event_loop()
    imap_conn = None

    try:
        imap_conn = await loop.run_in_executor(None, lambda: _connect_to_gmail(mail, pwd))
        uids_hour = await loop.run_in_executor(None, lambda: _search_last_hour(imap_conn, email_addr))
        if not uids_hour:
            return await temp.edit_text(f"No hay correos de Netflix en la última hora para {email_addr}.")
        uids_15m = await loop.run_in_executor(None, lambda: _filter_uids_last_15m(imap_conn, uids_hour))
        if not uids_15m:
            return await temp.edit_text(f"No hay correos de Netflix en los últimos 15 minutos para {email_addr}.")

        if flow == "fh":
            results = await loop.run_in_executor(None, lambda: _extract_household_links(imap_conn, uids_15m))
            links = [l for l in results.values() if l]
            if not links:
                await temp.edit_text("No se encontraron enlaces de ubicación principal en los últimos 15 minutos.")
            else:
                for link in links:
                    await update.message.reply_text(
                        f"📧 Recibido de: info@account.netflix.com\n"
                        f"➤ Recibido en: {email_addr}\n"
                        f"🔗 Enlace de ubicación principal: {link}"
                    )
                await temp.delete()
            feature = "enlace de ubicación principal"

        elif flow == "fs":
            results = await loop.run_in_executor(None, lambda: _extract_signin_codes(imap_conn, uids_15m))
            codes = [c for c in results.values() if c]
            if not codes:
                await temp.edit_text("No se encontraron códigos de inicio de sesión en los últimos 15 minutos.")
            else:
                for code in codes:
                    await update.message.reply_text(
                        f"📧 Recibido de: info@account.netflix.com\n"
                        f"➤ Recibido en: <code>{email_addr}</code>\n"
                        f"🔑 Código de inicio de sesión: <code>{code}</code>",
                        parse_mode="HTML"
                    )
                await temp.delete()
            feature = "código de inicio de sesión"

        else:
            results = await loop.run_in_executor(None, lambda: _extract_reset_links(imap_conn, uids_15m))
            links = [l for l in results.values() if l]
            if not links:
                await temp.edit_text("No se encontraron enlaces de restablecimiento de contraseña en los últimos 15 minutos.")
            else:
                for link in links:
                    await update.message.reply_text(
                        f"📧 Recibido de: info@account.netflix.com\n"
                        f"➤ Recibido en: {email_addr}\n"
                        f"🛡️ Enlace de restablecimiento: {link}"
                    )
                await temp.delete()
            feature = "enlace de restablecimiento de contraseña"

    except Exception as e:
        logger.error(f"Error durante IMAP fetch: {e}", exc_info=True)
        await update.message.reply_text("Ocurrió un error al obtener los correos.")
    finally:
        if imap_conn:
            try:
                await loop.run_in_executor(None, imap_conn.logout)
            except:
                pass

    user = update.effective_user
    mention = f"[{user.id}](tg://user?id={user.id})"
    fullname = user.full_name
    uname = f"@{escape_md(user.username)}" if user.username else ""
    lines = ["Alerta 🚨", mention, fullname]
    if uname:
        lines.append(uname)
    lines.append(f"este usuario solicitó {feature} y se envió correctamente.")
    lines.append(f"correo: {email_addr}")
    alert_text = "\n".join(lines)
    kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Desaprobar a este usuario", callback_data=f"disapprove_cb:{user.id}"))
    await context.bot.send_message(ADMIN_CHAT_ID, alert_text, parse_mode="Markdown", reply_markup=kb)

async def handle_admin_mail_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    if MAIL_FLOW_FLAG in context.user_data:
        chat_id = context.user_data.pop(MAIL_FLOW_FLAG)
        lines = [l.strip() for l in update.message.text.splitlines()]
        valid, invalid = [], []
        email_re = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")
        for l in lines:
            if email_re.match(l):
                valid.append(l)
            elif l:
                invalid.append(l)
        if not valid:
            return await update.message.reply_text("No se detectaron direcciones de correo válidas. Por favor envía correos válidos, uno por línea.")
        data = load_db()
        usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
        if not usr:
            return await update.message.reply_text("Usuario no encontrado.")
        usr["mails"] = valid
        save_db(data)
        markup = build_access_markup(chat_id)
        msg = f"Aprobado {chat_id} por {usr['days']} días para correos específicos."
        if invalid:
            msg += f"\nSe ignoraron líneas no válidas: {', '.join(invalid)}"
        return await update.message.reply_text(msg, reply_markup=markup)
    if "unlink_for" in context.user_data:
        chat_id = context.user_data.pop("unlink_for")
        lines = [l.strip() for l in update.message.text.splitlines() if l.strip()]
        data = load_db()
        usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
        removed, skipped = [], []
        for mail in lines:
            if usr and mail in usr.get("mails", []):
                usr["mails"].remove(mail)
                removed.append(mail)
            else:
                skipped.append(mail)
        save_db(data)
        return await update.message.reply_text(f"Desvinculados: {removed}\nOmitidos: {skipped}")
    if "link_for" in context.user_data:
        chat_id = context.user_data.pop("link_for")
        lines = [l.strip() for l in update.message.text.splitlines() if l.strip()]
        email_re = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")
        valid, invalid = [], []
        for l in lines:
            if email_re.match(l):
                valid.append(l)
            else:
                invalid.append(l)
        data = load_db()
        usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
        added = []
        for mail in valid:
            if usr and mail not in usr.get("mails", []):
                usr.setdefault("mails", []).append(mail)
                added.append(mail)
        save_db(data)
        msg = f"Nuevos correos vinculados: {added}"
        if invalid:
            msg += f"\nEntradas inválidas omitidas: {invalid}"
        return await update.message.reply_text(msg)

# ─────────────────────────────────────────────────────────────────────────────
# Broadcast handler for /send command and media with /send in caption
# ─────────────────────────────────────────────────────────────────────────────
async def broadcast_from_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return

    msg = update.message
    text = msg.text or ""
    caption = msg.caption or ""
    args = context.args
    has_media = any([msg.photo, msg.video, msg.document, msg.sticker, msg.animation])

    if not has_media and not args:
        return await msg.reply_text(
            "📣 *Uso para difusiones:*\n"
            "• `/send <mensaje>` para difundir texto\n"
            "• Adjunta una foto/video/documento/etc con un pie de foto que empiece con `/send` para difundir medios",
            parse_mode="Markdown"
        )

    if has_media and not caption.strip().startswith("/send"):
        return await msg.reply_text(
            "📣 *Uso para difusiones con medios:*\n"
            "Adjunta tu medio con un pie de foto que comience con `/send <mensaje>`",
            parse_mode="Markdown"
        )

    if has_media:
        body = caption.strip()[len("/send"):].lstrip()
    else:
        body = " ".join(args)

    header = "<u>⚜️ Mensaje del administrador</u>\n\n"
    full_caption = header + (body if body else "")

    data = load_db()
    user_ids = [u["id"] for u in data["credentials"][0]["users"]]

    tasks = []
    if not has_media:
        for uid in user_ids:
            tasks.append(context.bot.send_message(
                chat_id=uid,
                text=full_caption,
                parse_mode="HTML"
            ))
    else:
        if msg.photo:
            file_id = msg.photo[-1].file_id
            for uid in user_ids:
                tasks.append(context.bot.send_photo(
                    chat_id=uid,
                    photo=file_id,
                    caption=full_caption,
                    parse_mode="HTML"
                ))
        elif msg.video:
            file_id = msg.video.file_id
            for uid in user_ids:
                tasks.append(context.bot.send_video(
                    chat_id=uid,
                    video=file_id,
                    caption=full_caption,
                    parse_mode="HTML"
                ))
        elif msg.document:
            file_id = msg.document.file_id
            for uid in user_ids:
                tasks.append(context.bot.send_document(
                    chat_id=uid,
                    document=file_id,
                    caption=full_caption,
                    parse_mode="HTML"
                ))
        elif msg.sticker:
            file_id = msg.sticker.file_id
            for uid in user_ids:
                tasks.append(context.bot.send_sticker(
                    chat_id=uid,
                    sticker=file_id
                ))
        elif msg.animation:
            file_id = msg.animation.file_id
            for uid in user_ids:
                tasks.append(context.bot.send_animation(
                    chat_id=uid,
                    animation=file_id,
                    caption=full_caption,
                    parse_mode="HTML"
                ))
        else:
            return await msg.reply_text("❌ Tipo de medio no compatible para la difusión.")

    try:
        await asyncio.gather(*tasks)
        await msg.reply_text(f"✅ Enviado correctamente a {len(user_ids)} usuarios.")
    except Exception:
        tb = traceback.format_exc()
        bio = BytesIO(tb.encode("utf-8"))
        bio.name = "broadcast_error.txt"
        await context.bot.send_document(
            OWNER_CHAT_ID,
            document=bio,
            filename=bio.name,
            caption="Error durante la difusión"
        )

if __name__ == "__main__":
    if not Path(DB_FILE).exists():
        initialize_db()

    application = ApplicationBuilder().token(BOT_TOKEN).build()

    cfg_conv = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
            CallbackQueryHandler(cfg_start_cb, pattern="^cfg_start$"),
            CallbackQueryHandler(cfg_clear_cb, pattern="^cfg_clear$"),
            CommandHandler("reconfigure", reconfigure_handler),
        ],
        states={
            ADMIN_EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_email_received)],
            ADMIN_PASS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, admin_pass_received),
                CallbackQueryHandler(cfg_start_cb, pattern="^cfg_start$")
            ],
        },
        fallbacks=[CallbackQueryHandler(cfg_clear_cb, pattern="^cfg_clear$")],
        allow_reentry=True,
    )
    application.add_handler(cfg_conv)

    application.add_handler(CommandHandler("mail", mail_cmd))
    application.add_handler(CommandHandler("fetch", fetch_cmd))
    application.add_handler(CommandHandler("request", request_handler))
    application.add_handler(CommandHandler("status", status))
    application.add_handler(CommandHandler("users", list_users))
    application.add_handler(CommandHandler("approve", approve))
    application.add_handler(CommandHandler("extend", extend))
    application.add_handler(CommandHandler("disapprove", disapprove))
    application.add_handler(CommandHandler("terminate", terminate))
    application.add_handler(CommandHandler("support", support))
    application.add_handler(CommandHandler("commands", commands))
    application.add_handler(CommandHandler("info", info_cmd))

    application.add_handler(CallbackQueryHandler(toggle_feature_cb, pattern=r"^(toggle_household|toggle_signin|toggle_reset|disapprove_cb):"))
    application.add_handler(CallbackQueryHandler(handle_set_all_mails_cb, pattern=r"^set_all_mails:-?\d+$"))
    application.add_handler(CallbackQueryHandler(handle_set_specified_mails_cb, pattern=r"^set_specified_mails:-?\d+$"))
    application.add_handler(CallbackQueryHandler(handle_cancel_specify_mails, pattern=r"^cancel_specify:-?\d+$"))
    application.add_handler(CallbackQueryHandler(handle_unlink_all_email, pattern="^unlink_all_email:"))
    application.add_handler(CallbackQueryHandler(handle_info_go_back, pattern="^info_go_back$"))
    application.add_handler(CallbackQueryHandler(handle_see_specified_mails, pattern="^see_specified_mails:-?\d+$"))
    application.add_handler(CallbackQueryHandler(cancel_cb, pattern="^cancel_cb$"))
    application.add_handler(CallbackQueryHandler(unlink_mail_user_cb, pattern="^unlink_mail_user_cb:-?\d+$"))
    application.add_handler(CallbackQueryHandler(link_mail_user_cb, pattern="^link_mail_user_cb:-?\d+$"))
    application.add_handler(CallbackQueryHandler(handle_fh, pattern="^fh$"))
    application.add_handler(CallbackQueryHandler(handle_fs, pattern="^fs$"))
    application.add_handler(CallbackQueryHandler(handle_fr, pattern="^fr$"))
    application.add_handler(CallbackQueryHandler(handle_go_back, pattern="^go_back$"))

    application.add_handler(
        MessageHandler(
            filters.TEXT & ~filters.COMMAND & filters.Chat(ADMIN_CHAT_ID),
            handle_admin_mail_input
        )
    )

    application.add_handler(
        MessageHandler(
            filters.TEXT & ~filters.COMMAND & ~filters.Chat(ADMIN_CHAT_ID),
            handle_flow_email
        )
    )

    media_send_filter = filters.Chat(ADMIN_CHAT_ID) & filters.CaptionRegex(r"^/send")
    application.add_handler(MessageHandler(media_send_filter, broadcast_from_admin))

    application.add_error_handler(on_error)

    logger.info("Bot starting…")
    application.run_polling()

    print("Initialization complete")
