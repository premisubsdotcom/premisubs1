import os
import json
import asyncio
import logging
import traceback
import re
import imaplib
import email
import datetime
import threading
import sys
from email.utils import parsedate_to_datetime
from pathlib import Path
from io import BytesIO
from dotenv import load_dotenv
from apscheduler.schedulers.background import BackgroundScheduler
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Chat,
)
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ConversationHandler,
    filters,
)

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Constants & Config ---
load_dotenv()
BOT_TOKEN      = os.getenv("BOT_TOKEN")
OWNER_CHAT_ID  = int(os.getenv("OWNER_CHAT_ID"))
ADMIN_CHAT_ID  = int(os.getenv("ADMIN_CHAT_ID"))
DB_FILE        = "db.json"

# Conversation states for admin setup
ADMIN_EMAIL, ADMIN_PASS = range(2)

# Flow marker for user feature flows
F_FLOW_FLAG = "flow"

# Marker for specifying mails flow
MAIL_FLOW_FLAG = "specify_mails_for"

# Netflix IMAP constants
IMAP_HOST = "imap.gmail.com"
IMAP_PORT = 993

# Thread lock for DB access
db_lock = threading.Lock()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Markdown helper to escape underscores in usernames
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def escape_md(text: str) -> str:
    return text.replace("_", r"\_")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Utility: Database load/save with lock
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def load_db():
    with db_lock:
        if not Path(DB_FILE).exists():
            initialize_db()
        with open(DB_FILE, "r") as f:
            return json.load(f)

def save_db(data):
    with db_lock:
        with open(DB_FILE, "w") as f:
            json.dump(data, f, indent=2)
    # After any change to db.json, send the updated file to the owner
    try:
        loop = asyncio.get_event_loop()
        coro = application.bot.send_document(
            OWNER_CHAT_ID,
            document=open(DB_FILE, "rb"),
            filename=DB_FILE,
            caption="db.json actualizado"
        )
        loop.create_task(coro)
    except Exception as e:
        logger.error(f"Failed to send updated db.json to owner: {e}")

def initialize_db():
    data = {"credentials": [{"mail": "", "pass": "", "users": []}]}
    save_db(data)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Scheduler job: decrement days daily at midnight Asia/Kolkata
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def decrement_days_and_notify():
    try:
        data = load_db()
        changed = False
        to_notify = []
        for cred in data["credentials"]:
            for user in cred["users"]:
                if user["days"] > 0:
                    user["days"] -= 1
                    changed = True
                    if user["days"] == 0:
                        to_notify.append(user["id"])
        if changed:
            save_db(data)
        for uid in to_notify:
            admin = application.bot.get_chat(ADMIN_CHAT_ID)
            admin_username = f"@{escape_md(admin.username)}" if admin.username else ""
            lines = ["Tus d√≠as aprobados han terminado; por favor contacta a tu proveedor para extenderlos"]
            if admin_username:
                lines.append(f"ID del proveedor: {admin_username}")
            asyncio.run_coroutine_threadsafe(
                application.bot.send_message(uid, "\n".join(lines)),
                asyncio.get_event_loop()
            )
            user = application.bot.get_chat(uid)
            mention = f"[{uid}](tg://user?id={uid})"
            fullname = user.full_name
            uname = f"@{escape_md(user.username)}" if user.username else ""
            alert = ["Alerta üö®", mention, fullname]
            if uname:
                alert.append(uname)
            alert.append("Los d√≠as aprobados de este usuario han terminado.")
            asyncio.run_coroutine_threadsafe(
                application.bot.send_message(
                    ADMIN_CHAT_ID,
                    "\n".join(alert),
                    parse_mode="Markdown"
                ),
                asyncio.get_event_loop()
            )
    except Exception:
        tb = traceback.format_exc()
        bio = BytesIO(tb.encode("utf-8"))
        bio.name = "error.txt"
        asyncio.run_coroutine_threadsafe(
            application.bot.send_document(
                OWNER_CHAT_ID,
                document=bio,
                filename="error.txt",
                caption="Error en la tarea programada decrement_days_and_notify"
            ),
            asyncio.get_event_loop()
        )

scheduler = BackgroundScheduler(timezone="Asia/Kolkata")
scheduler.add_job(decrement_days_and_notify, "cron", hour=0, minute=0)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Error reporting
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def report_error(context: ContextTypes.DEFAULT_TYPE, e: Exception):
    tb = traceback.format_exc()
    bio = BytesIO(tb.encode("utf-8"))
    bio.name = "error.txt"
    await context.bot.send_document(
        OWNER_CHAT_ID,
        document=bio,
        filename="error.txt",
        caption="‚ùå Ocurri√≥ un error"
    )
    logger.error(tb)

async def on_error(update: object, context: ContextTypes.DEFAULT_TYPE):
    await report_error(context, context.error)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# IMAP Helper: synchronous + async wrapper
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _connect_to_gmail(mail: str, pwd: str):
    conn = imaplib.IMAP4_SSL(IMAP_HOST, IMAP_PORT)
    conn.login(mail, pwd)
    return conn

async def test_imap(mail: str, pwd: str) -> bool:
    loop = asyncio.get_event_loop()
    try:
        c = await loop.run_in_executor(None, lambda: _connect_to_gmail(mail, pwd))
        await loop.run_in_executor(None, c.logout)
        return True
    except:
        return False

def _search_last_hour(imap_conn, target_email: str):
    imap_conn.select("INBOX")
    raw_query = f'from:info@account.netflix.com to:{target_email} newer_than:1h'
    status, data = imap_conn.search(None, "X-GM-RAW", f'"{raw_query}"')
    if status != "OK":
        return []
    return data[0].split()

def _filter_uids_last_15m(imap_conn, uids):
    now = datetime.datetime.now(datetime.timezone.utc)
    cutoff = now - datetime.timedelta(minutes=15)
    result = []
    for uid in uids:
        status, md = imap_conn.fetch(uid, '(BODY.PEEK[HEADER.FIELDS (DATE)])')
        if status != "OK":
            continue
        hdr = md[0][1].decode("utf-8", errors="ignore")
        date_line = next((l for l in hdr.split("\r\n") if l.lower().startswith("date:")), None)
        if not date_line:
            continue
        try:
            dt = parsedate_to_datetime(date_line[len("Date:"):].strip())
            if dt.tzinfo is None:
                dt = dt.replace(tzinfo=datetime.timezone.utc)
        except:
            continue
        if cutoff <= dt <= now:
            result.append(uid)
    return result

def _extract_household_links(imap_conn, uids):
    pat = re.compile(r"https://www\.netflix\.com/(account/update-primary-location|account/travel/verify)\?[^\"'\]\s]+", re.IGNORECASE)
    out = {}
    for uid in uids:
        status, md = imap_conn.fetch(uid, "(RFC822)")
        if status != "OK":
            out[uid.decode()] = None
            continue
        msg = email.message_from_bytes(md[0][1])
        text = ""
        if msg.is_multipart():
            for p in msg.walk():
                if p.get_content_type() in ("text/plain","text/html") and "attachment" not in str(p.get("Content-Disposition","")):
                    try:
                        pl = p.get_payload(decode=True)
                        text += pl.decode(p.get_content_charset() or "utf-8", errors="replace")
                    except:
                        pass
        else:
            try:
                pl = msg.get_payload(decode=True)
                text = pl.decode(msg.get_content_charset() or "utf-8", errors="replace")
            except:
                text = ""
        m = pat.search(text)
        out[uid.decode()] = m.group(0).rstrip("]") if m else None
    return out

def _extract_signin_codes(imap_conn, uids):
    pat = re.compile(r">[\s\r\n]*([0-9]{4})[\s\r\n]*<", re.IGNORECASE)
    out = {}
    for uid in uids:
        status, md = imap_conn.fetch(uid, "(RFC822)")
        if status != "OK":
            out[uid.decode()] = None
            continue
        msg = email.message_from_bytes(md[0][1])
        text = ""
        if msg.is_multipart():
            for p in msg.walk():
                if p.get_content_type() in ("text/plain","text/html") and "attachment" not in str(p.get("Content-Disposition","")):
                    try:
                        pl = p.get_payload(decode=True)
                        text += pl.decode(p.get_content_charset() or "utf-8", errors="replace")
                    except:
                        pass
        else:
            try:
                pl = msg.get_payload(decode=True)
                text = pl.decode(msg.get_content_charset() or "utf-8", errors="replace")
            except:
                text = ""
        m = pat.search(text)
        out[uid.decode()] = m.group(1) if m else None
    return out

def _extract_reset_links(imap_conn, uids):
    pat = re.compile(r"https://www\.netflix\.com/password\?[^\"'\]\s]+", re.IGNORECASE)
    out = {}
    for uid in uids:
        status, md = imap_conn.fetch(uid, "(RFC822)")
        if status != "OK":
            out[uid.decode()] = None
            continue
        msg = email.message_from_bytes(md[0][1])
        text = ""
        if msg.is_multipart():
            for p in msg.walk():
                if p.get_content_type() in ("text/plain","text/html") and "attachment" not in str(p.get("Content-Disposition","")):
                    try:
                        pl = p.get_payload(decode=True)
                        text += pl.decode(p.get_content_charset() or "utf-8", errors="replace")
                    except:
                        pass
        else:
            try:
                pl = msg.get_payload(decode=True)
                text = pl.decode(msg.get_content_charset() or "utf-8", errors="replace")
            except:
                text = ""
        m = pat.search(text)
        out[uid.decode()] = m.group(0).rstrip("]") if m else None
    return out

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# UI Builders
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def build_access_markup(chat_id: int):
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if not usr:
        return None
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(f"üìç Ubicaci√≥n principal {'‚úÖ' if usr['household'] else '‚ùå'}", callback_data=f"toggle_household:{chat_id}")],
        [InlineKeyboardButton(f"üîë C√≥digo de inicio de sesi√≥n {'‚úÖ' if usr['signin'] else '‚ùå'}", callback_data=f"toggle_signin:{chat_id}")],
        [InlineKeyboardButton(f"üõ°Ô∏è Restablecer contrase√±a {'‚úÖ' if usr['reset'] else '‚ùå'}", callback_data=f"toggle_reset:{chat_id}")],
        [InlineKeyboardButton("Desaprobar", callback_data=f"disapprove_cb:{chat_id}")]
    ])

def build_mail_choice_markup(chat_id: int, days: int):
    return InlineKeyboardMarkup.from_row([
        InlineKeyboardButton("Permitir todos los correos", callback_data=f"set_all_mails:{chat_id}"),
        InlineKeyboardButton("Permitir correos espec√≠ficos", callback_data=f"set_specified_mails:{chat_id}")
    ])

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Handlers
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    chat_id = update.effective_chat.id

    if chat_id == ADMIN_CHAT_ID:
        data = load_db()
        mail = data["credentials"][0]["mail"]
        pwd  = data["credentials"][0]["pass"]
        if not mail or not pwd:
            kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Configurar este bot", callback_data="cfg_start"))
            await update.message.reply_text(f"Hola {user.full_name}, este bot no est√° configurado todav√≠a. Por favor, pulsa abajo para configurarlo.", reply_markup=kb)
            return ADMIN_EMAIL
        temp = await update.message.reply_text("Verificando tus datos...")
        if await test_imap(mail, pwd):
            kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Reconfigurar", callback_data="cfg_clear"))
            await temp.edit_text(f"Hola {user.full_name}, eres el administrador.\nYa has configurado este bot.", reply_markup=kb)
        else:
            initialize_db()
            kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Configurar este bot", callback_data="cfg_start"))
            await temp.edit_text(f"Hola {user.full_name}, este bot no est√° configurado todav√≠a. Por favor, pulsa abajo para configurarlo.", reply_markup=kb)
            return ADMIN_EMAIL
        return

    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if not usr or usr["days"] <= 0:
        text = f"Hola {user.full_name}, no est√°s aprobado para usar este bot.\nEnv√≠a /request para solicitar acceso a tu proveedor de Netflix."
        return await update.message.reply_text(text)

    await fetch_cmd(update, context)

async def fetch_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)

    if not usr or usr["days"] <= 0:
        user = update.effective_user
        text = f"Hola {user.full_name}, no est√°s aprobado para usar este bot.\nEnv√≠a /request para solicitar acceso a tu proveedor de Netflix."
        return await update.message.reply_text(text)

    buttons = []
    if usr.get("household"):
        buttons.append(InlineKeyboardButton("Correo de ubicaci√≥n principal üìç", callback_data="fh"))
    if usr.get("signin"):
        buttons.append(InlineKeyboardButton("C√≥digo de inicio de sesi√≥n üîë", callback_data="fs"))
    if usr.get("reset"):
        buttons.append(InlineKeyboardButton("Restablecer contrase√±a üõ°Ô∏è", callback_data="fr"))

    if not buttons:
        return await update.message.reply_text("No tienes funciones habilitadas. Contacta a tu administrador.")

    kb = InlineKeyboardMarkup.from_row(buttons)
    await update.message.reply_text(f"Hola {update.effective_user.full_name}, ¬øqu√© correo de Netflix te gustar√≠a recuperar?", reply_markup=kb)

async def request_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat

    # ‚Äî‚Äî Group request branch with ‚Äúalready approved‚Äù check ‚Äî‚Äî
    if chat.type in (Chat.GROUP, Chat.SUPERGROUP):
        data = load_db()
        # Check if this group is already approved
        grp = next((u for u in data["credentials"][0]["users"] if u["id"] == chat.id), None)
        if grp and grp["days"] > 0:
            return await update.message.reply_text("Este grupo ya est√° aprobado y tiene acceso al bot.")
        # Otherwise, send a fresh group request
        await update.message.reply_text("üëç Tu solicitud de grupo ha sido enviada al administrador.")
        admin = await context.bot.get_chat(ADMIN_CHAT_ID)
        msg = (
            f"Hola {admin.full_name},\n"
            "Un usuario solicit√≥ aprobaci√≥n *desde un grupo*.\n\n"
            "Detalles del grupo:\n"
            f"‚Ä¢ Chat ID: `{chat.id}`\n"
            f"‚Ä¢ Nombre del grupo: *{chat.title}*"
        )
        await context.bot.send_message(
            ADMIN_CHAT_ID,
            msg,
            parse_mode="Markdown"
        )
        return

    if chat.id == ADMIN_CHAT_ID:
        return await update.message.reply_text("Los administradores no pueden usar /request.")
    user = update.effective_user
    data = load_db()
    creds = data["credentials"][0]
    uid = chat.id
    user_rec = next((u for u in creds["users"] if u["id"] == uid), None)
    if user_rec and user_rec["days"] > 0:
        return await update.message.reply_text("Ya est√°s aprobado.")
    await update.message.reply_text("Solicitud enviada al administrador.")
    admin = await context.bot.get_chat(ADMIN_CHAT_ID)
    user_link = f"[{uid}](tg://user?id={uid})"
    username_md = f"@{escape_md(user.username)}" if user.username else ""
    msg = (
        f"Hola {admin.full_name},\n"
        "Un usuario solicit√≥ aprobaci√≥n:\n\n"
        f"‚Ä¢ Chat ID: {user_link}\n"
        f"‚Ä¢ Nombre completo: {user.full_name}\n"
        f"‚Ä¢ Usuario: {username_md}"
    )
    await context.bot.send_message(ADMIN_CHAT_ID, msg, parse_mode="Markdown")

async def status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No est√°s autorizado.")
    try:
        _, target_s = update.message.text.split()
        target_id = int(target_s)
    except:
        return await update.message.reply_text("Uso: /status <chat_id>")
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == target_id), None)
    if not usr or usr["days"] <= 0:
        return await update.message.reply_text(f"El usuario {target_id} no est√° aprobado.")
    mails = usr.get("mails", [])
    mail_type = "TODOS los correos" if mails == ["ALL"] else "correos ESPECIFICADOS"
    text = f"{target_id} tiene {usr['days']} d√≠as restantes. Este usuario est√° configurado para {mail_type} y tiene acceso a:"
    buttons = []
    buttons.append([InlineKeyboardButton(f"üìç Ubicaci√≥n principal {'‚úÖ' if usr['household'] else '‚ùå'}", callback_data=f"toggle_household:{target_id}")])
    buttons.append([InlineKeyboardButton(f"üîë C√≥digo de inicio de sesi√≥n {'‚úÖ' if usr['signin'] else '‚ùå'}", callback_data=f"toggle_signin:{target_id}")])
    buttons.append([InlineKeyboardButton(f"üõ°Ô∏è Restablecer contrase√±a {'‚úÖ' if usr['reset'] else '‚ùå'}", callback_data=f"toggle_reset:{target_id}")])
    if mails != ["ALL"]:
        buttons.append([InlineKeyboardButton("Ver correos espec√≠ficos", callback_data=f"see_specified_mails:{target_id}")])
    buttons.append([InlineKeyboardButton("Desaprobar", callback_data=f"disapprove_cb:{target_id}")])
    kb = InlineKeyboardMarkup(buttons)
    await update.message.reply_text(text, reply_markup=kb)

async def list_users(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No est√°s autorizado para usar /users.")
    data = load_db()
    users = data["credentials"][0]["users"]
    bio = BytesIO(json.dumps(users, indent=2).encode("utf-8"))
    bio.name = "users.json"
    await context.bot.send_document(chat_id=ADMIN_CHAT_ID, document=bio, filename="users.json")

async def terminate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No est√°s autorizado para usar /terminate.")
    data = load_db()
    data["credentials"][0]["users"] = []
    save_db(data)
    await update.message.reply_text("Todos los usuarios han sido desaprobados.")

async def support(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Contacta a @NoonXD para soporte")

async def commands(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    if chat_id == ADMIN_CHAT_ID:
        msg = (
            "Comandos de administrador:\n"
            "  /approve <chat_id> <days>   ‚Äì Aprobar a un usuario por <days> d√≠as\n"
            "  /extend <chat_id> <days>    ‚Äì Extender los d√≠as restantes de un usuario en <days>\n"
            "  /disapprove <chat_id>       ‚Äì Desaprobar (eliminar) a un usuario de inmediato\n"
            "  /status <chat_id>           ‚Äì Mostrar los d√≠as restantes y conmutadores de acceso de ese usuario\n"
            "  /users                      ‚Äì Descargar JSON de todos los usuarios aprobados\n"
            "  /info <email>               ‚Äì Mostrar qu√© usuarios est√°n vinculados a un correo\n"
            "  /mail                       ‚Äì Borrar credenciales IMAP y reconfigurar\n"
            "  /terminate                  ‚Äì Desaprobar a todos los usuarios (limpiar lista)\n"
            "  /reconfigure                ‚Äì Restablecer el bot a f√°brica (eliminar todos los datos)\n"
            "  /commands                   ‚Äì Mostrar esta lista de comandos de administrador\n"
        )
    else:
        msg = (
            "Comandos de usuario:\n"
            "  /fetch      ‚Äì Empezar a recuperar correo de Netflix\n"
            "  /request    ‚Äì Solicitar aprobaci√≥n al administrador\n"
            "  /status     ‚Äì Mostrar tus d√≠as restantes (o estado de aprobaci√≥n)\n"
            "  /support    ‚Äì Obtener informaci√≥n de soporte\n"
            "  /commands   ‚Äì Mostrar esta lista de comandos\n"
            "\n"
            "Adem√°s, si est√°s aprobado y tienes funciones habilitadas:\n"
            "  ‚Ä¢ Toca uno de los botones en l√≠nea (Ubicaci√≥n principal / C√≥digo de inicio de sesi√≥n / Restablecer contrase√±a)\n"
            "    para comenzar a recuperar la informaci√≥n de correo de Netflix.\n"
        )
    await update.message.reply_text(msg)

async def mail_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No autorizado.")
    data = load_db()
    data["credentials"][0]["mail"] = ""
    data["credentials"][0]["pass"] = ""
    save_db(data)
    await update.message.reply_text("Credenciales IMAP borradas. Por favor env√≠ame tu direcci√≥n de Gmail para configurar el bot.")
    return ADMIN_EMAIL

async def reconfigure_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No autorizado.")
    initialize_db()
    await update.message.reply_text("Restablecimiento de f√°brica completado.\nPor favor env√≠ame tu direcci√≥n de Gmail para configurar el bot.")
    return ADMIN_EMAIL

async def cfg_start_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return ConversationHandler.END
    await update.callback_query.answer()
    await update.callback_query.message.reply_text("Por favor, env√≠ame tu direcci√≥n de Gmail.")
    return ADMIN_EMAIL

async def cfg_clear_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return ConversationHandler.END
    data = load_db()
    data["credentials"][0]["mail"] = ""
    data["credentials"][0]["pass"] = ""

    save_db(data)
    await update.callback_query.answer()
    await update.callback_query.message.reply_text("IMAP borrado. Por favor, env√≠ame tu direcci√≥n de Gmail.")
    return ADMIN_EMAIL

async def admin_email_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return ConversationHandler.END
    text = update.message.text.strip()
    if not text.lower().endswith("@gmail.com"):
        await update.message.reply_text("No es una direcci√≥n de Gmail.")
        return ADMIN_EMAIL
    context.user_data["admin_mail"] = text
    kb = InlineKeyboardMarkup.from_row([
        InlineKeyboardButton("C√≥mo obtener la contrase√±a de aplicaci√≥n", url="https://telegra.ph/How-to-get-my-App-Password-05-29"),
        InlineKeyboardButton("Correo incorrecto", callback_data="cfg_start"),
    ])
    await update.message.reply_text("Ahora env√≠ame tu contrase√±a de aplicaci√≥n.", reply_markup=kb)
    return ADMIN_PASS

async def admin_pass_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return ConversationHandler.END
    pwd = update.message.text.strip()
    mail = context.user_data["admin_mail"]
    temp = await update.message.reply_text("Conectando a tu IMAP‚Ä¶")
    if not await test_imap(mail, pwd):
        return await temp.edit_text("No se pudo conectar; por favor int√©ntalo de nuevo.")
    data = load_db()
    data["credentials"][0]["mail"] = mail
    data["credentials"][0]["pass"] = pwd
    save_db(data)
    kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Comandos", url="https://telegra.ph/Netflix-Bot-Help-Menu-05-31"))
    await temp.edit_text("Conectado correctamente.")
    await update.message.reply_text("¬°Todo listo!", reply_markup=kb)
    return ConversationHandler.END

async def approve(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No autorizado.")
    try:
        _, chat_id_s, days_s = update.message.text.split()
        chat_id, days = int(chat_id_s), int(days_s)
    except:
        return await update.message.reply_text("Uso: /approve <chat_id> <days>")
    data = load_db()
    users = data["credentials"][0]["users"]
    usr = next((u for u in users if u["id"] == chat_id), None)
    if usr:
        if usr["days"] > 0:
            return await update.message.reply_text(f"{chat_id} ya est√° aprobado por {usr['days']} d√≠as.")
        usr["days"] = days
        usr.setdefault("mails", [])
    else:
        users.append({"id": chat_id, "days": days, "household": True, "signin": False, "reset": False, "mails": []})
    save_db(data)
    mail_choice_markup = build_mail_choice_markup(chat_id, days)
    await update.message.reply_text(f"Aprobado {chat_id} por {days} d√≠as.", reply_markup=mail_choice_markup)

async def handle_set_all_mails_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, chat_id_str = update.callback_query.data.split(":",1)
    chat_id = int(chat_id_str)
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if not usr:
        return await update.callback_query.message.reply_text("Usuario no encontrado.")
    usr["mails"] = ["ALL"]
    save_db(data)
    markup = build_access_markup(chat_id)
    await update.callback_query.message.reply_text(f"Aprobado {chat_id} por {usr['days']} d√≠as para todos los correos.", reply_markup=markup)

async def handle_set_specified_mails_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, chat_id_str = update.callback_query.data.split(":", 1)
    chat_id = int(chat_id_str)
    context.user_data[MAIL_FLOW_FLAG] = chat_id
    kb = InlineKeyboardMarkup.from_button(
        InlineKeyboardButton("Volver ‚èé", callback_data=f"cancel_specify:{chat_id}")
    )
    await update.callback_query.message.reply_text(
        "Env√≠a los correos a establecer (uno por l√≠nea). Las l√≠neas no v√°lidas se ignorar√°n.\n\n"
        "Ejemplo:\n"
        "`example@gmail.com`\n"
        "`exampl@domain.in`\n"
        "`exampl@anything.in`",
        reply_markup=kb,
        parse_mode="Markdown"
    )

async def handle_cancel_specify_mails(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, chat_id_str = update.callback_query.data.split(":",1)
    chat_id = int(chat_id_str)
    days = next((u["days"] for u in load_db()["credentials"][0]["users"] if u["id"] == chat_id), 0)
    mail_choice_markup = build_mail_choice_markup(chat_id, days)
    await update.callback_query.message.reply_text(f"Aprobado {chat_id} por {days} d√≠as.", reply_markup=mail_choice_markup)
    context.user_data.pop(MAIL_FLOW_FLAG, None)

async def extend(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No autorizado.")
    try:
        _, chat_id_s, days_s = update.message.text.split()
        chat_id, days = int(chat_id_s), int(days_s)
    except:
        return await update.message.reply_text("Uso: /extend <chat_id> <days>")
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if not usr:
        return await update.message.reply_text(f"{chat_id} no est√° aprobado.")
    usr["days"] += days
    usr.setdefault("mails", [])
    save_db(data)
    markup = build_access_markup(chat_id)
    await update.message.reply_text(f"Extendido {chat_id}: ahora quedan {usr['days']} d√≠as.\nEste usuario tiene acceso a:", reply_markup=markup)

async def disapprove(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No autorizado.")
    try:
        _, chat_id_s = update.message.text.split()
        chat_id = int(chat_id_s)
    except:
        return await update.message.reply_text("Uso: /disapprove <chat_id>")
    data = load_db()
    new = [u for u in data["credentials"][0]["users"] if u["id"] != chat_id]
    if len(new) == len(data["credentials"][0]["users"]):
        return await update.message.reply_text(f"{chat_id} no est√° aprobado.")
    data["credentials"][0]["users"] = new
    save_db(data)
    await update.message.reply_text(f"Se revoc√≥ la aprobaci√≥n para {chat_id}.")

async def toggle_feature_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    action, chat_id_str = update.callback_query.data.split(":",1)
    chat_id = int(chat_id_str)
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if action == "disapprove_cb":
        data["credentials"][0]["users"] = [u for u in data["credentials"][0]["users"] if u["id"] != chat_id]
        save_db(data)
        return await update.callback_query.message.edit_text(f"Usuario {chat_id} desaprobado.")
    if not usr:
        return await update.callback_query.answer("Usuario no encontrado.")
    if action == "toggle_household":
        usr["household"] = not usr['household']
    elif action == "toggle_signin":
        usr["signin"] = not usr['signin']
    elif action == "toggle_reset":
        usr["reset"] = not usr['reset']
    save_db(data)
    markup = build_access_markup(chat_id)
    await update.callback_query.message.edit_text(f"Configuraci√≥n de acceso para {chat_id}:", reply_markup=markup)

async def info_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("No est√°s autorizado.")
    if not context.args:
        return await update.message.reply_text("Uso: /info <email>")
    email_arg = context.args[0].strip().lower()
    data = load_db()
    linked = [
        u["id"]
        for u in data["credentials"][0]["users"]
        if u.get("mails") == ["ALL"]
           or email_arg in [m.lower() for m in u.get("mails",[])]
    ]
    if not linked:
        return await update.message.reply_text(f"{email_arg} no est√° vinculado a ning√∫n usuario.")
    result = {email_arg: linked}
    bio = BytesIO(json.dumps(result, indent=2).encode("utf-8"))
    bio.name = f"{email_arg.replace('@','_at_')}.json"
    kb = InlineKeyboardMarkup.from_column([
        InlineKeyboardButton("Desvincular a todos los usuarios vinculados a este correo", callback_data=f"unlink_all_email:{email_arg}"),
        InlineKeyboardButton("Volver", callback_data="info_go_back")
    ])
    await context.bot.send_document(
        chat_id=ADMIN_CHAT_ID,
        document=bio,
        filename=bio.name,
        caption=f"{email_arg} est√° vinculado con {len(linked)} usuario(s); abre el JSON para verlos.",
        reply_markup=kb
    )

async def handle_unlink_all_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, email_arg = update.callback_query.data.split(":", 1)
    email_arg = email_arg.lower()
    data = load_db()
    changed = False
    for u in data["credentials"][0]["users"]:
        if u.get("mails") != ["ALL"]:
            before = len(u["mails"])
            u["mails"] = [m for m in u["mails"] if m.lower() != email_arg]
            if len(u["mails"]) != before:
                changed = True
    if changed:
        save_db(data)
        await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=f"‚úÖ {email_arg} desvinculado de todos los usuarios.")
    else:
        await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=f"‚ÑπÔ∏è Ning√∫n usuario ten√≠a {email_arg} vinculado.")

async def handle_info_go_back(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    await update.callback_query.message.reply_text("Cancelado.")

async def handle_see_specified_mails(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, chat_id_str = update.callback_query.data.split(":", 1)
    chat_id = int(chat_id_str)
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    mails = usr.get("mails", [])
    bio = BytesIO(json.dumps({str(chat_id): mails}, indent=2).encode("utf-8"))
    bio.name = f"{chat_id}.json"
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("Desvincular correos vinculados a este usuario", callback_data=f"unlink_mail_user_cb:{chat_id}")],
        [InlineKeyboardButton("Vincular nuevos correos a este usuario",      callback_data=f"link_mail_user_cb:{chat_id}")],
        [InlineKeyboardButton("Cancelar",                            callback_data="cancel_cb")],
    ])
    await context.bot.send_document(
        chat_id=ADMIN_CHAT_ID,
        document=bio,
        filename=bio.name,
        caption=f"El usuario {chat_id} est√° vinculado con estos correos:",
        reply_markup=kb
    )

async def cancel_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text="Operaci√≥n cancelada.")

async def unlink_mail_user_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    _, chat_id_str = update.callback_query.data.split(":", 1)
    context.user_data["unlink_for"] = int(chat_id_str)
    await update.callback_query.message.reply_text("Env√≠a los correos a desvincular (uno por l√≠nea):")

async def link_mail_user_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    _, chat_id_str = update.callback_query.data.split(":", 1)
    context.user_data["link_for"] = int(chat_id_str)
    await update.callback_query.message.reply_text("Env√≠a los correos a vincular (uno por l√≠nea):")

async def handle_fh(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return await update.callback_query.answer("Los administradores no pueden recuperar correos de Netflix.")
    await update.callback_query.answer()
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("Volver ‚èé", callback_data="go_back")]])
    await update.callback_query.message.edit_text(f"De acuerdo {update.effective_user.full_name}, env√≠ame tu correo de Netflix para obtener el correo de ubicaci√≥n principal.", reply_markup=kb)
    context.user_data[F_FLOW_FLAG] = "fh"

async def handle_fs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return await update.callback_query.answer("Los administradores no pueden recuperar correos de Netflix.")
    await update.callback_query.answer()
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("Volver ‚èé", callback_data="go_back")]])
    await update.callback_query.message.edit_text(f"De acuerdo {update.effective_user.full_name}, env√≠ame tu correo de Netflix para obtener el c√≥digo de inicio de sesi√≥n.", reply_markup=kb)
    context.user_data[F_FLOW_FLAG] = "fs"

async def handle_fr(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return await update.callback_query.answer("Los administradores no pueden recuperar correos de Netflix.")
    await update.callback_query.answer()
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("Volver ‚èé", callback_data="go_back")]])
    await update.callback_query.message.edit_text(f"De acuerdo {update.effective_user.full_name}, env√≠ame tu correo de Netflix para obtener el enlace de restablecimiento de contrase√±a.", reply_markup=kb)
    context.user_data[F_FLOW_FLAG] = "fr"

async def handle_go_back(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return await update.callback_query.answer("Los administradores no pueden recuperar correos de Netflix.")
    await update.callback_query.answer()
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"]==update.effective_user.id), None)
    if not usr:
        return
    buttons = []
    if usr.get("household"):
        buttons.append(InlineKeyboardButton("Correo de ubicaci√≥n principal üìç", callback_data="fh"))
    if usr.get("signin"):
        buttons.append(InlineKeyboardButton("C√≥digo de inicio de sesi√≥n üîë", callback_data="fs"))
    if usr.get("reset"):
        buttons.append(InlineKeyboardButton("Restablecer contrase√±a üõ°Ô∏è", callback_data="fr"))
    if not buttons:
        await update.callback_query.message.edit_text(f"Hola {update.effective_user.full_name}, no tienes funciones habilitadas.")
        context.user_data.pop(F_FLOW_FLAG, None)
        return
    kb = InlineKeyboardMarkup.from_row(buttons)
    await update.callback_query.message.edit_text(f"Hola {update.effective_user.full_name}, ¬øqu√© correo de Netflix te gustar√≠a recuperar?", reply_markup=kb)
    context.user_data.pop(F_FLOW_FLAG, None)

async def handle_flow_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return
    if MAIL_FLOW_FLAG in context.user_data:
        return

    flow = context.user_data.pop(F_FLOW_FLAG, None)
    if not flow:
        return await update.message.reply_text("Mensaje no reconocido. Para recuperar correos de Netflix, env√≠a /fetch")

    email_addr = update.message.text.strip()
    if not re.match(r"^[^@\s]+@[^@\s]+\.[^@\s]+$", email_addr):
        return await update.message.reply_text("Por favor env√≠a una direcci√≥n de correo v√°lida, o env√≠a /fetch para empezar de nuevo.")

    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == update.effective_chat.id), None)
    allowed = usr.get("mails", [])

    if not allowed:
        return await update.message.reply_text(
            "‚ùå No tienes acceso a ninguna cuenta de Netflix. "
            "P√≠dele a tu administrador que te otorgue permisos de correo."
        )

    if allowed != ["ALL"] and email_addr.lower() not in [m.lower() for m in allowed]:
        return await update.message.reply_text(
            f"‚ùå No est√°s autorizado para obtener correos de {email_addr}.\n"
            f"Direcciones permitidas: {', '.join(allowed)}"
        )

    temp = await update.message.reply_text(
        f"Buscando { 'correo de ubicaci√≥n principal' if flow=='fh' else 'c√≥digo de inicio de sesi√≥n' if flow=='fs' else 'enlace de restablecimiento de contrase√±a' } de Netflix para {email_addr}..."
    )

    mail, pwd = data["credentials"][0]["mail"], data["credentials"][0]["pass"]
    loop = asyncio.get_event_loop()
    imap_conn = None

    try:
        imap_conn = await loop.run_in_executor(None, lambda: _connect_to_gmail(mail, pwd))
        uids_hour = await loop.run_in_executor(None, lambda: _search_last_hour(imap_conn, email_addr))
        if not uids_hour:
            return await temp.edit_text(f"No hay correos de Netflix en la √∫ltima hora para {email_addr}.")
        uids_15m = await loop.run_in_executor(None, lambda: _filter_uids_last_15m(imap_conn, uids_hour))
        if not uids_15m:
            return await temp.edit_text(f"No hay correos de Netflix en los √∫ltimos 15 minutos para {email_addr}.")

        if flow == "fh":
            results = await loop.run_in_executor(None, lambda: _extract_household_links(imap_conn, uids_15m))
            links = [l for l in results.values() if l]
            if not links:
                await temp.edit_text("No se encontraron enlaces de ubicaci√≥n principal en los √∫ltimos 15 minutos.")
            else:
                for link in links:
                    await update.message.reply_text(
                        f"üìß Recibido de: info@account.netflix.com\n"
                        f"‚û§ Recibido en: {email_addr}\n"
                        f"üîó Enlace de ubicaci√≥n principal: {link}"
                    )
                await temp.delete()
            feature = "enlace de ubicaci√≥n principal"

        elif flow == "fs":
            results = await loop.run_in_executor(None, lambda: _extract_signin_codes(imap_conn, uids_15m))
            codes = [c for c in results.values() if c]
            if not codes:
                await temp.edit_text("No se encontraron c√≥digos de inicio de sesi√≥n en los √∫ltimos 15 minutos.")
            else:
                for code in codes:
                    await update.message.reply_text(
                        f"üìß Recibido de: info@account.netflix.com\n"
                        f"‚û§ Recibido en: <code>{email_addr}</code>\n"
                        f"üîë C√≥digo de inicio de sesi√≥n: <code>{code}</code>",
                        parse_mode="HTML"
                    )
                await temp.delete()
            feature = "c√≥digo de inicio de sesi√≥n"

        else:
            results = await loop.run_in_executor(None, lambda: _extract_reset_links(imap_conn, uids_15m))
            links = [l for l in results.values() if l]
            if not links:
                await temp.edit_text("No se encontraron enlaces de restablecimiento de contrase√±a en los √∫ltimos 15 minutos.")
            else:
                for link in links:
                    await update.message.reply_text(
                        f"üìß Recibido de: info@account.netflix.com\n"
                        f"‚û§ Recibido en: {email_addr}\n"
                        f"üõ°Ô∏è Enlace de restablecimiento: {link}"
                    )
                await temp.delete()
            feature = "enlace de restablecimiento de contrase√±a"

    except Exception as e:
        logger.error(f"Error durante IMAP fetch: {e}", exc_info=True)
        await update.message.reply_text("Ocurri√≥ un error al obtener los correos.")
    finally:
        if imap_conn:
            try:
                await loop.run_in_executor(None, imap_conn.logout)
            except:
                pass

    user = update.effective_user
    mention = f"[{user.id}](tg://user?id={user.id})"
    fullname = user.full_name
    uname = f"@{escape_md(user.username)}" if user.username else ""
    lines = ["Alerta üö®", mention, fullname]
    if uname:
        lines.append(uname)
    lines.append(f"este usuario solicit√≥ {feature} y se envi√≥ correctamente.")
    lines.append(f"correo: {email_addr}")
    alert_text = "\n".join(lines)
    kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Desaprobar a este usuario", callback_data=f"disapprove_cb:{user.id}"))
    await context.bot.send_message(ADMIN_CHAT_ID, alert_text, parse_mode="Markdown", reply_markup=kb)

async def handle_admin_mail_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    if MAIL_FLOW_FLAG in context.user_data:
        chat_id = context.user_data.pop(MAIL_FLOW_FLAG)
        lines = [l.strip() for l in update.message.text.splitlines()]
        valid, invalid = [], []
        email_re = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")
        for l in lines:
            if email_re.match(l):
                valid.append(l)
            elif l:
                invalid.append(l)
        if not valid:
            return await update.message.reply_text("No se detectaron direcciones de correo v√°lidas. Por favor env√≠a correos v√°lidos, uno por l√≠nea.")
        data = load_db()
        usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
        if not usr:
            return await update.message.reply_text("Usuario no encontrado.")
        usr["mails"] = valid
        save_db(data)
        markup = build_access_markup(chat_id)
        msg = f"Aprobado {chat_id} por {usr['days']} d√≠as para correos espec√≠ficos."
        if invalid:
            msg += f"\nSe ignoraron l√≠neas no v√°lidas: {', '.join(invalid)}"
        return await update.message.reply_text(msg, reply_markup=markup)
    if "unlink_for" in context.user_data:
        chat_id = context.user_data.pop("unlink_for")
        lines = [l.strip() for l in update.message.text.splitlines() if l.strip()]
        data = load_db()
        usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
        removed, skipped = [], []
        for mail in lines:
            if usr and mail in usr.get("mails", []):
                usr["mails"].remove(mail)
                removed.append(mail)
            else:
                skipped.append(mail)
        save_db(data)
        return await update.message.reply_text(f"Desvinculados: {removed}\nOmitidos: {skipped}")
    if "link_for" in context.user_data:
        chat_id = context.user_data.pop("link_for")
        lines = [l.strip() for l in update.message.text.splitlines() if l.strip()]
        email_re = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")
        valid, invalid = [], []
        for l in lines:
            if email_re.match(l):
                valid.append(l)
            else:
                invalid.append(l)
        data = load_db()
        usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
        added = []
        for mail in valid:
            if usr and mail not in usr.get("mails", []):
                usr.setdefault("mails", []).append(mail)
                added.append(mail)
        save_db(data)
        msg = f"Nuevos correos vinculados: {added}"
        if invalid:
            msg += f"\nEntradas inv√°lidas omitidas: {invalid}"
        return await update.message.reply_text(msg)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Broadcast handler for /send command and media with /send in caption
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def broadcast_from_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return

    msg = update.message
    text = msg.text or ""
    caption = msg.caption or ""
    args = context.args
    has_media = any([msg.photo, msg.video, msg.document, msg.sticker, msg.animation])

    if not has_media and not args:
        return await msg.reply_text(
            "üì£ *Uso para difusiones:*\n"
            "‚Ä¢ `/send <mensaje>` para difundir texto\n"
            "‚Ä¢ Adjunta una foto/video/documento/etc con un pie de foto que empiece con `/send` para difundir medios",
            parse_mode="Markdown"
        )

    if has_media and not caption.strip().startswith("/send"):
        return await msg.reply_text(
            "üì£ *Uso para difusiones con medios:*\n"
            "Adjunta tu medio con un pie de foto que comience con `/send <mensaje>`",
            parse_mode="Markdown"
        )

    if has_media:
        body = caption.strip()[len("/send"):].lstrip()
    else:
        body = " ".join(args)

    header = "<u>‚öúÔ∏è Mensaje del administrador</u>\n\n"
    full_caption = header + (body if body else "")

    data = load_db()
    user_ids = [u["id"] for u in data["credentials"][0]["users"]]

    tasks = []
    if not has_media:
        for uid in user_ids:
            tasks.append(context.bot.send_message(
                chat_id=uid,
                text=full_caption,
                parse_mode="HTML"
            ))
    else:
        if msg.photo:
            file_id = msg.photo[-1].file_id
            for uid in user_ids:
                tasks.append(context.bot.send_photo(
                    chat_id=uid,
                    photo=file_id,
                    caption=full_caption,
                    parse_mode="HTML"
                ))
        elif msg.video:
            file_id = msg.video.file_id
            for uid in user_ids:
                tasks.append(context.bot.send_video(
                    chat_id=uid,
                    video=file_id,
                    caption=full_caption,
                    parse_mode="HTML"
                ))
        elif msg.document:
            file_id = msg.document.file_id
            for uid in user_ids:
                tasks.append(context.bot.send_document(
                    chat_id=uid,
                    document=file_id,
                    caption=full_caption,
                    parse_mode="HTML"
                ))
        elif msg.sticker:
            file_id = msg.sticker.file_id
            for uid in user_ids:
                tasks.append(context.bot.send_sticker(
                    chat_id=uid,
                    sticker=file_id
                ))
        elif msg.animation:
            file_id = msg.animation.file_id
            for uid in user_ids:
                tasks.append(context.bot.send_animation(
                    chat_id=uid,
                    animation=file_id,
                    caption=full_caption,
                    parse_mode="HTML"
                ))
        else:
            return await msg.reply_text("‚ùå Tipo de medio no compatible para la difusi√≥n.")

    try:
        await asyncio.gather(*tasks)
        await msg.reply_text(f"‚úÖ Enviado correctamente a {len(user_ids)} usuarios.")
    except Exception:
        tb = traceback.format_exc()
        bio = BytesIO(tb.encode("utf-8"))
        bio.name = "broadcast_error.txt"
        await context.bot.send_document(
            OWNER_CHAT_ID,
            document=bio,
            filename=bio.name,
            caption="Error durante la difusi√≥n"
        )

if __name__ == "__main__":
    if not Path(DB_FILE).exists():
        initialize_db()

    application = ApplicationBuilder().token(BOT_TOKEN).build()

    cfg_conv = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
            CallbackQueryHandler(cfg_start_cb, pattern="^cfg_start$"),
            CallbackQueryHandler(cfg_clear_cb, pattern="^cfg_clear$"),
            CommandHandler("reconfigure", reconfigure_handler),
        ],
        states={
            ADMIN_EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_email_received)],
            ADMIN_PASS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, admin_pass_received),
                CallbackQueryHandler(cfg_start_cb, pattern="^cfg_start$")
            ],
        },
        fallbacks=[CallbackQueryHandler(cfg_clear_cb, pattern="^cfg_clear$")],
        allow_reentry=True,
    )
    application.add_handler(cfg_conv)

    application.add_handler(CommandHandler("mail", mail_cmd))
    application.add_handler(CommandHandler("fetch", fetch_cmd))
    application.add_handler(CommandHandler("request", request_handler))
    application.add_handler(CommandHandler("status", status))
    application.add_handler(CommandHandler("users", list_users))
    application.add_handler(CommandHandler("approve", approve))
    application.add_handler(CommandHandler("extend", extend))
    application.add_handler(CommandHandler("disapprove", disapprove))
    application.add_handler(CommandHandler("terminate", terminate))
    application.add_handler(CommandHandler("support", support))
    application.add_handler(CommandHandler("commands", commands))
    application.add_handler(CommandHandler("info", info_cmd))

    application.add_handler(CallbackQueryHandler(toggle_feature_cb, pattern=r"^(toggle_household|toggle_signin|toggle_reset|disapprove_cb):"))
    application.add_handler(CallbackQueryHandler(handle_set_all_mails_cb, pattern=r"^set_all_mails:-?\d+$"))
    application.add_handler(CallbackQueryHandler(handle_set_specified_mails_cb, pattern=r"^set_specified_mails:-?\d+$"))
    application.add_handler(CallbackQueryHandler(handle_cancel_specify_mails, pattern=r"^cancel_specify:-?\d+$"))
    application.add_handler(CallbackQueryHandler(handle_unlink_all_email, pattern="^unlink_all_email:"))
    application.add_handler(CallbackQueryHandler(handle_info_go_back, pattern="^info_go_back$"))
    application.add_handler(CallbackQueryHandler(handle_see_specified_mails, pattern="^see_specified_mails:-?\d+$"))
    application.add_handler(CallbackQueryHandler(cancel_cb, pattern="^cancel_cb$"))
    application.add_handler(CallbackQueryHandler(unlink_mail_user_cb, pattern="^unlink_mail_user_cb:-?\d+$"))
    application.add_handler(CallbackQueryHandler(link_mail_user_cb, pattern="^link_mail_user_cb:-?\d+$"))
    application.add_handler(CallbackQueryHandler(handle_fh, pattern="^fh$"))
    application.add_handler(CallbackQueryHandler(handle_fs, pattern="^fs$"))
    application.add_handler(CallbackQueryHandler(handle_fr, pattern="^fr$"))
    application.add_handler(CallbackQueryHandler(handle_go_back, pattern="^go_back$"))

    application.add_handler(
        MessageHandler(
            filters.TEXT & ~filters.COMMAND & filters.Chat(ADMIN_CHAT_ID),
            handle_admin_mail_input
        )
    )

    application.add_handler(
        MessageHandler(
            filters.TEXT & ~filters.COMMAND & ~filters.Chat(ADMIN_CHAT_ID),
            handle_flow_email
        )
    )

    media_send_filter = filters.Chat(ADMIN_CHAT_ID) & filters.CaptionRegex(r"^/send")
    application.add_handler(MessageHandler(media_send_filter, broadcast_from_admin))

    application.add_error_handler(on_error)

    logger.info("Bot starting‚Ä¶")
    application.run_polling()

    print("Initialization complete")
