# Modified bot.py ‚Äî improved error handling, scheduler loop integration,
# safe message edits, and controlled DB-send behavior

import os
import json
import asyncio
import logging
import traceback
import re
import imaplib
import email
import datetime
import threading
import sys
from email.utils import parsedate_to_datetime
from pathlib import Path
from io import BytesIO
from dotenv import load_dotenv
from apscheduler.schedulers.background import BackgroundScheduler
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Chat,
)
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ConversationHandler,
    filters,
)
import telegram.error

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Globals that will be assigned later ---
application = None  # will be assigned in __main__
app_loop = None     # asyncio loop used by scheduler/background threads

# --- Constants & Config ---
load_dotenv()
BOT_TOKEN      = os.getenv("BOT_TOKEN")
OWNER_CHAT_ID  = int(os.getenv("OWNER_CHAT_ID")) if os.getenv("OWNER_CHAT_ID") else None
ADMIN_CHAT_ID  = int(os.getenv("ADMIN_CHAT_ID")) if os.getenv("ADMIN_CHAT_ID") else None
DB_FILE        = "db.json"

# Control automatic sending of db.json on every save (default: off).
# Set SEND_DB_ON_CHANGE=1 in environment to re-enable.
SEND_DB_ON_CHANGE = os.getenv("SEND_DB_ON_CHANGE", "0") == "1"

# Conversation states for admin setup
ADMIN_EMAIL, ADMIN_PASS = range(2)

# Flow marker for user feature flows
F_FLOW_FLAG = "flow"

# Marker for specifying mails flow
MAIL_FLOW_FLAG = "specify_mails_for"

# Netflix IMAP constants
IMAP_HOST = "imap.gmail.com"
IMAP_PORT = 993

# Thread lock for DB access
db_lock = threading.Lock()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Markdown helper to escape underscores in usernames
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def escape_md(text: str) -> str:
    return text.replace("_", r"\_")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Helpers for safe bot operations
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def get_app_loop():
    """
    Return the asyncio loop for scheduling coroutines from other threads.
    Falls back to asyncio.get_event_loop() if app_loop not set.
    """
    global app_loop
    if app_loop:
        return app_loop
    try:
        return asyncio.get_running_loop()
    except RuntimeError:
        # No running loop in this thread; try get_event_loop
        try:
            return asyncio.get_event_loop()
        except Exception:
            return None

async def safe_edit_message(message_obj, text, **kwargs):
    """
    Try to edit a message. If message is None or edit fails with
    'Message is not modified', fallback to sending a new message.
    """
    if message_obj is None:
        # nothing to edit
        return None
    try:
        return await message_obj.edit_text(text, **kwargs)
    except telegram.error.BadRequest as e:
        # ignore "Message is not modified" errors, but bubble up unexpected BadRequest forms
        msg = str(e)
        if "Message is not modified" in msg or "message is not modified" in msg.lower():
            logger.debug("Ignored BadRequest: Message is not modified")
            return None
        # If edit failed because original message can't be edited (maybe deleted), send new message
        chat = None
        try:
            chat = message_obj.chat_id
        except Exception:
            chat = None
        if chat:
            try:
                # best-effort fallback: send new message to same chat
                return await application.bot.send_message(chat_id=chat, text=text, **kwargs)
            except Exception as ex2:
                logger.exception("Failed to send fallback message after failed edit: %s", ex2)
                return None
        logger.exception("Unhandled BadRequest when editing message: %s", e)
        return None
    except Exception:
        logger.exception("Unexpected exception in safe_edit_message")
        return None

def safe_schedule_coroutine(coro):
    """
    Submit coroutine to the main app loop from another thread (scheduler).
    Returns concurrent.futures.Future or None if cannot schedule.
    """
    loop = get_app_loop()
    if loop:
        try:
            return asyncio.run_coroutine_threadsafe(coro, loop)
        except Exception:
            logger.exception("Failed to schedule coroutine on app loop")
            return None
    else:
        logger.warning("No app loop available to schedule coroutine")
        return None

async def safe_send_document(chat_id, file_bytesio, filename=None, caption=None, reply_markup=None):
    """
    Safely send a document if application and bot are available.
    """
    if application is None:
        logger.warning("Application not ready ‚Äî cannot send document")
        return None
    try:
        file_bytesio.seek(0)
        return await application.bot.send_document(chat_id, document=file_bytesio, filename=filename or file_bytesio.name, caption=caption, reply_markup=reply_markup)
    except Exception:
        logger.exception("Failed to send document")
        return None

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Utility: Database load/save with lock
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def load_db():
    with db_lock:
        if not Path(DB_FILE).exists():
            initialize_db()
        with open(DB_FILE, "r") as f:
            return json.load(f)

def save_db(data):
    """
    Save JSON data to DB_FILE. Optionally send updated DB to OWNER_CHAT_ID if
    SEND_DB_ON_CHANGE env var is set. This avoids spamming the owner on every change.
    """
    with db_lock:
        with open(DB_FILE, "w") as f:
            json.dump(data, f, indent=2)

    if SEND_DB_ON_CHANGE and OWNER_CHAT_ID:
        # send db file to owner but guarded and scheduled on main loop
        try:
            bio = BytesIO(json.dumps(data, indent=2).encode("utf-8"))
            bio.name = DB_FILE
            # schedule coroutine safely
            safe_schedule_coroutine(safe_send_document(OWNER_CHAT_ID, bio, filename=DB_FILE, caption="Updated db.json"))
        except Exception:
            logger.exception("Failed to schedule db send to owner after save")

def initialize_db():
    data = {"credentials": [{"mail": "", "pass": "", "users": []}]}
    # avoid sending on initialization by default (save_db guards with SEND_DB_ON_CHANGE)
    save_db(data)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Scheduler job: decrement days daily at midnight Asia/Kolkata
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def decrement_days_and_notify():
    """
    This function runs in a scheduler thread. It schedules any bot messages on the
    main app loop via safe_schedule_coroutine.
    """
    try:
        data = load_db()
        changed = False
        to_notify = []
        for cred in data["credentials"]:
            for user in cred["users"]:
                if user["days"] > 0:
                    user["days"] -= 1
                    changed = True
                    if user["days"] == 0:
                        to_notify.append(user["id"])
        if changed:
            save_db(data)

        for uid in to_notify:
            async def _notify(uid_local):
                try:
                    admin = await application.bot.get_chat(ADMIN_CHAT_ID) if ADMIN_CHAT_ID else None
                    admin_username = f"@{escape_md(admin.username)}" if admin and admin.username else ""
                    lines = ["Your approved days are complete so please contact your supplier to extend the days"]
                    if admin_username:
                        lines.append(f"supplier id: {admin_username}")
                    await application.bot.send_message(uid_local, "\n".join(lines))

                    # Notify admin as well
                    user = await application.bot.get_chat(uid_local)
                    mention = f"[{uid_local}](tg://user?id={uid_local})"
                    fullname = user.full_name
                    uname = f"@{escape_md(user.username)}" if user.username else ""
                    alert = ["Alert üö®", mention, fullname]
                    if uname:
                        alert.append(uname)
                    alert.append("This user‚Äôs approval days have ended.")
                    await application.bot.send_message(
                        ADMIN_CHAT_ID,
                        "\n".join(alert),
                        parse_mode="Markdown"
                    )
                except Exception:
                    tb = traceback.format_exc()
                    bio = BytesIO(tb.encode("utf-8"))
                    bio.name = "error.txt"
                    # Try to send error file to owner/admin
                    if OWNER_CHAT_ID:
                        await safe_send_document(OWNER_CHAT_ID, bio, filename="error.txt", caption="Error in scheduled decrement_days_and_notify")
                    logger.exception("Exception while sending decrement notification")

            safe_schedule_coroutine(_notify(uid))
    except Exception:
        tb = traceback.format_exc()
        bio = BytesIO(tb.encode("utf-8"))
        bio.name = "error.txt"
        if OWNER_CHAT_ID:
            safe_schedule_coroutine(safe_send_document(OWNER_CHAT_ID, bio, filename="error.txt", caption="Error in scheduled decrement_days_and_notify"))
        logger.exception("Exception in decrement_days_and_notify")

scheduler = BackgroundScheduler(timezone="Asia/Kolkata")
# job runs daily at 00:00 Asia/Kolkata
scheduler.add_job(decrement_days_and_notify, "cron", hour=0, minute=0)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Error reporting
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def report_error(context: ContextTypes.DEFAULT_TYPE, e: Exception):
    tb = traceback.format_exc()
    bio = BytesIO(tb.encode("utf-8"))
    bio.name = "error.txt"
    if OWNER_CHAT_ID:
        await safe_send_document(OWNER_CHAT_ID, bio, filename="error.txt", caption="‚ùå Error Occurred")
    logger.error(tb)

async def on_error(update: object, context: ContextTypes.DEFAULT_TYPE):
    await report_error(context, context.error)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# IMAP Helper: synchronous + async wrapper
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _connect_to_gmail(mail: str, pwd: str):
    conn = imaplib.IMAP4_SSL(IMAP_HOST, IMAP_PORT)
    conn.login(mail, pwd)
    return conn

async def test_imap(mail: str, pwd: str) -> bool:
    loop = asyncio.get_event_loop()
    try:
        c = await loop.run_in_executor(None, lambda: _connect_to_gmail(mail, pwd))
        # logout in executor (callable without args)
        await loop.run_in_executor(None, lambda: c.logout())
        return True
    except Exception:
        logger.debug("IMAP test failed", exc_info=True)
        return False

def _search_last_hour(imap_conn, target_email: str):
    try:
        imap_conn.select("INBOX")
        raw_query = f'from:info@account.netflix.com to:{target_email} newer_than:1h'
        status, data = imap_conn.search(None, "X-GM-RAW", f'"{raw_query}"')
        if status != "OK":
            return []
        return data[0].split()
    except Exception:
        logger.exception("Error during _search_last_hour")
        return []

def _filter_uids_last_15m(imap_conn, uids):
    now = datetime.datetime.now(datetime.timezone.utc)
    cutoff = now - datetime.timedelta(minutes=15)
    result = []
    for uid in uids:
        try:
            status, md = imap_conn.fetch(uid, '(BODY.PEEK[HEADER.FIELDS (DATE)])')
            if status != "OK":
                continue
            hdr = md[0][1].decode("utf-8", errors="ignore")
            date_line = next((l for l in hdr.split("\r\n") if l.lower().startswith("date:")), None)
            if not date_line:
                continue
            try:
                dt = parsedate_to_datetime(date_line[len("Date:"):].strip())
                if dt.tzinfo is None:
                    dt = dt.replace(tzinfo=datetime.timezone.utc)
            except Exception:
                continue
            if cutoff <= dt <= now:
                result.append(uid)
        except Exception:
            logger.debug("Failed to filter uid %s", uid, exc_info=True)
            continue
    return result

def _extract_household_links(imap_conn, uids):
    pat = re.compile(r"https://www\.netflix\.com/(account/update-primary-location|account/travel/verify)\?[^\"'\]\s]+", re.IGNORECASE)
    out = {}
    for uid in uids:
        try:
            status, md = imap_conn.fetch(uid, "(RFC822)")
            if status != "OK":
                out[uid.decode() if isinstance(uid, bytes) else str(uid)] = None
                continue
            raw = md[0][1]
            msg = email.message_from_bytes(raw)
            text = ""
            if msg.is_multipart():
                for p in msg.walk():
                    if p.get_content_type() in ("text/plain","text/html") and "attachment" not in str(p.get("Content-Disposition","")):
                        try:
                            pl = p.get_payload(decode=True)
                            text += pl.decode(p.get_content_charset() or "utf-8", errors="replace")
                        except Exception:
                            pass
            else:
                try:
                    pl = msg.get_payload(decode=True)
                    text = pl.decode(msg.get_content_charset() or "utf-8", errors="replace")
                except Exception:
                    text = ""
            m = pat.search(text)
            out_key = uid.decode() if isinstance(uid, bytes) else str(uid)
            out[out_key] = m.group(0).rstrip("]") if m else None
        except Exception:
            logger.exception("Failed to extract household link for uid %s", uid)
            out_key = uid.decode() if isinstance(uid, bytes) else str(uid)
            out[out_key] = None
    return out

def _extract_signin_codes(imap_conn, uids):
    pat = re.compile(r">[\s\r\n]*([0-9]{4})[\s\r\n]*<", re.IGNORECASE)
    out = {}
    for uid in uids:
        try:
            status, md = imap_conn.fetch(uid, "(RFC822)")
            if status != "OK":
                out[uid.decode() if isinstance(uid, bytes) else str(uid)] = None
                continue
            msg = email.message_from_bytes(md[0][1])
            text = ""
            if msg.is_multipart():
                for p in msg.walk():
                    if p.get_content_type() in ("text/plain","text/html") and "attachment" not in str(p.get("Content-Disposition","")):
                        try:
                            pl = p.get_payload(decode=True)
                            text += pl.decode(p.get_content_charset() or "utf-8", errors="replace")
                        except Exception:
                            pass
            else:
                try:
                    pl = msg.get_payload(decode=True)
                    text = pl.decode(msg.get_content_charset() or "utf-8", errors="replace")
                except Exception:
                    text = ""
            m = pat.search(text)
            out_key = uid.decode() if isinstance(uid, bytes) else str(uid)
            out[out_key] = m.group(1) if m else None
        except Exception:
            logger.exception("Failed to extract signin code for uid %s", uid)
            out_key = uid.decode() if isinstance(uid, bytes) else str(uid)
            out[out_key] = None
    return out

def _extract_reset_links(imap_conn, uids):
    pat = re.compile(r"https://www\.netflix\.com/password\?[^\"'\]\s]+", re.IGNORECASE)
    out = {}
    for uid in uids:
        try:
            status, md = imap_conn.fetch(uid, "(RFC822)")
            if status != "OK":
                out[uid.decode() if isinstance(uid, bytes) else str(uid)] = None
                continue
            msg = email.message_from_bytes(md[0][1])
            text = ""
            if msg.is_multipart():
                for p in msg.walk():
                    if p.get_content_type() in ("text/plain","text/html") and "attachment" not in str(p.get("Content-Disposition","")):
                        try:
                            pl = p.get_payload(decode=True)
                            text += pl.decode(p.get_content_charset() or "utf-8", errors="replace")
                        except Exception:
                            pass
            else:
                try:
                    pl = msg.get_payload(decode=True)
                    text = pl.decode(msg.get_content_charset() or "utf-8", errors="replace")
                except Exception:
                    text = ""
            m = pat.search(text)
            out_key = uid.decode() if isinstance(uid, bytes) else str(uid)
            out[out_key] = m.group(0).rstrip("]") if m else None
        except Exception:
            logger.exception("Failed to extract reset link for uid %s", uid)
            out_key = uid.decode() if isinstance(uid, bytes) else str(uid)
            out[out_key] = None
    return out

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# UI Builders
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def build_access_markup(chat_id: int):
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if not usr:
        return None
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(f"üìç Household {'‚úÖ' if usr['household'] else '‚ùå'}", callback_data=f"toggle_household:{chat_id}")],
        [InlineKeyboardButton(f"üîë Sign-in Code {'‚úÖ' if usr['signin'] else '‚ùå'}", callback_data=f"toggle_signin:{chat_id}")],
        [InlineKeyboardButton(f"üõ°Ô∏è Password Reset {'‚úÖ' if usr['reset'] else '‚ùå'}", callback_data=f"toggle_reset:{chat_id}")],
        [InlineKeyboardButton("Disapprove", callback_data=f"disapprove_cb:{chat_id}")]
    ])

def build_mail_choice_markup(chat_id: int, days: int):
    return InlineKeyboardMarkup.from_row([
        InlineKeyboardButton("Set all mails", callback_data=f"set_all_mails:{chat_id}"),
        InlineKeyboardButton("Set specified mails", callback_data=f"set_specified_mails:{chat_id}")
    ])

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Handlers
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    chat_id = update.effective_chat.id

    if chat_id == ADMIN_CHAT_ID:
        data = load_db()
        mail = data["credentials"][0]["mail"]
        pwd  = data["credentials"][0]["pass"]
        if not mail or not pwd:
            kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Configure this bot", callback_data="cfg_start"))
            return await update.message.reply_text(f"Hey {user.full_name}, this bot is not configured yet. Please click below to configure.", reply_markup=kb)
        temp = await update.message.reply_text("Checking your details...")
        if await test_imap(mail, pwd):
            kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Reconfigure", callback_data="cfg_clear"))
            await safe_edit_message(temp, f"Hey {user.full_name}, you are the captain\nYou already configured this bot.", reply_markup=kb)
        else:
            initialize_db()
            kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Configure this bot", callback_data="cfg_start"))
            await safe_edit_message(temp, f"Hey {user.full_name}, this bot is not configured yet. Please click below to configure.", reply_markup=kb)
            return ADMIN_EMAIL
        return

    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if not usr or usr["days"] <= 0:
        text = f"Hey {user.full_name}, you are not approved to use this bot.\nSend /request to ask for access to your Netflix supplier/seller."
        return await update.message.reply_text(text)

    await fetch_cmd(update, context)

async def fetch_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)

    if not usr or usr["days"] <= 0:
        user = update.effective_user
        text = f"Hey {user.full_name}, you are not approved to use this bot.\nSend /request to ask for access to your Netflix supplier/seller."
        return await update.message.reply_text(text)

    buttons = []
    if usr.get("household"):
        buttons.append(InlineKeyboardButton("Household Mail üìç", callback_data="fh"))
    if usr.get("signin"):
        buttons.append(InlineKeyboardButton("Sign-in Code üîë", callback_data="fs"))
    if usr.get("reset"):
        buttons.append(InlineKeyboardButton("Password Reset üõ°Ô∏è", callback_data="fr"))

    if not buttons:
        return await update.message.reply_text("You have no features enabled. Contact your admin.")

    kb = InlineKeyboardMarkup.from_row(buttons)
    await update.message.reply_text(f"Hey {update.effective_user.full_name}, which Netflix mail would you like to retrieve?", reply_markup=kb)

async def request_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat

    # ‚Äî‚Äî Group request branch with ‚Äúalready approved‚Äù check ‚Äî‚Äî
    if chat.type in (Chat.GROUP, Chat.SUPERGROUP):
        data = load_db()
        # Check if this group is already approved
        grp = next((u for u in data["credentials"][0]["users"] if u["id"] == chat.id), None)
        if grp and grp["days"] > 0:
            return await update.message.reply_text("This group is already approved and has access to the bot.")
        # Otherwise, send a fresh group request
        await update.message.reply_text("üëç Your group request has been sent to the admin.")
        admin = await context.bot.get_chat(ADMIN_CHAT_ID)
        msg = (
            f"Hey {admin.full_name},\n"
            "Some user requested approval *from a group*.\n\n"
            "Group details:\n"
            f"‚Ä¢ Chat ID: `{chat.id}`\n"
            f"‚Ä¢ Group name: *{chat.title}*"
        )
        await context.bot.send_message(
            ADMIN_CHAT_ID,
            msg,
            parse_mode="Markdown"
        )
        return

    if chat.id == ADMIN_CHAT_ID:
        return await update.message.reply_text("Admins cannot use /request.")
    user = update.effective_user
    data = load_db()
    creds = data["credentials"][0]
    uid = chat.id
    user_rec = next((u for u in creds["users"] if u["id"] == uid), None)
    if user_rec and user_rec["days"] > 0:
        return await update.message.reply_text("You are already approved.")
    await update.message.reply_text("Request sent to admin.")
    admin = await context.bot.get_chat(ADMIN_CHAT_ID)
    user_link = f"[{uid}](tg://user?id={uid})"
    username_md = f"@{escape_md(user.username)}" if user.username else ""
    msg = (
        f"Hey {admin.full_name},\n"
        "Some user requested approval:\n\n"
        f"‚Ä¢ Chat ID: {user_link}\n"
        f"‚Ä¢ Full name: {user.full_name}\n"
        f"‚Ä¢ Username: {username_md}"
    )
    await context.bot.send_message(ADMIN_CHAT_ID, msg, parse_mode="Markdown")

async def status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("You are not authorized.")
    try:
        _, target_s = update.message.text.split()
        target_id = int(target_s)
    except:
        return await update.message.reply_text("Usage: /status <chat_id>")
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == target_id), None)
    if not usr or usr["days"] <= 0:
        return await update.message.reply_text(f"User {target_id} is not approved.")
    mails = usr.get("mails", [])
    mail_type = "ALL mails" if mails == ["ALL"] else "SPECIFIED mails"
    text = f"{target_id} has {usr['days']} days left. This user is set to {mail_type} and has access to:"
    buttons = []
    buttons.append([InlineKeyboardButton(f"üìç Household {'‚úÖ' if usr['household'] else '‚ùå'}", callback_data=f"toggle_household:{target_id}")])
    buttons.append([InlineKeyboardButton(f"üîë Sign-in Code {'‚úÖ' if usr['signin'] else '‚ùå'}", callback_data=f"toggle_signin:{target_id}")])
    buttons.append([InlineKeyboardButton(f"üõ°Ô∏è Password Reset {'‚úÖ' if usr['reset'] else '‚ùå'}", callback_data=f"toggle_reset:{target_id}")])
    if mails != ["ALL"]:
        buttons.append([InlineKeyboardButton("See specified mails", callback_data=f"see_specified_mails:{target_id}")])
    buttons.append([InlineKeyboardButton("Disapprove mails", callback_data=f"disapprove_cb:{target_id}")])
    kb = InlineKeyboardMarkup(buttons)
    await update.message.reply_text(text, reply_markup=kb)

async def list_users(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("You are not authorized to use /users.")
    data = load_db()
    users = data["credentials"][0]["users"]
    bio = BytesIO(json.dumps(users, indent=2).encode("utf-8"))
    bio.name = "users.json"
    await context.bot.send_document(chat_id=ADMIN_CHAT_ID, document=bio, filename="users.json")

async def terminate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("You are not authorized to use /terminate.")
    data = load_db()
    data["credentials"][0]["users"] = []
    save_db(data)
    await update.message.reply_text("All users have been disapproved.")

async def support(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Contact @NoonXD for support")

async def commands(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    if chat_id == ADMIN_CHAT_ID:
        msg = (
            "Admin commands:\n"
            "  /approve <chat_id> <days>   ‚Äì Approve a user for <days> days\n"
            "  /extend <chat_id> <days>    ‚Äì Extend a user's remaining days by <days>\n"
            "  /disapprove <chat_id>       ‚Äì Disapprove (remove) a user immediately\n"
            "  /status <chat_id>           ‚Äì Show that user's days left and access toggles\n"
            "  /users                      ‚Äì Download JSON of all approved users\n"
            "  /info <email>               ‚Äì Show which users are linked to an email\n"
            "  /mail                       ‚Äì Clear IMAP credentials and reconfigure\n"
            "  /terminate                  ‚Äì Disapprove all users (clear users list)\n"
            "  /reconfigure                ‚Äì Factory reset the bot (delete all data)\n"
            "  /commands                   ‚Äì Show this list of admin commands\n"
            "  /dumpdb                     ‚Äì Send current db.json to OWNER (if set)\n"
        )
    else:
        msg = (
            "User commands:\n"
            "  /fetch      ‚Äì Start retrieving Netflix mail\n"
            "  /request    ‚Äì Request approval from the admin\n"
            "  /status     ‚Äì Show your remaining days (or approval status)\n"
            "  /support    ‚Äì Get support contact info\n"
            "  /commands   ‚Äì Show this list of user commands\n"
            "\n"
            "Plus, if approved and you have features enabled:\n"
            "  ‚Ä¢ Tap one of the inline buttons (Household / Sign-in Code / Password Reset)\n"
            "    to start retrieving your Netflix mail info.\n"
        )
    await update.message.reply_text(msg)

async def mail_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("Not authorized.")
    data = load_db()
    data["credentials"][0]["mail"] = ""
    data["credentials"][0]["pass"] = ""
    save_db(data)
    await update.message.reply_text("IMAP credentials cleared. Please send me your Gmail address to configure the bot.")
    return ADMIN_EMAIL

async def reconfigure_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("Not authorized.")
    initialize_db()
    await update.message.reply_text("Factory reset complete.\nPlease send me your Gmail address to configure the bot.")
    return ADMIN_EMAIL

async def cfg_start_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return ConversationHandler.END
    await update.callback_query.answer()
    await update.callback_query.message.reply_text("Please send me your Gmail address.")
    return ADMIN_EMAIL

async def cfg_clear_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return ConversationHandler.END
    data = load_db()
    data["credentials"][0]["mail"] = ""
    data["credentials"][0]["pass"] = ""
    save_db(data)
    await update.callback_query.answer()
    await update.callback_query.message.reply_text("IMAP cleared. Please send me your Gmail address.")
    return ADMIN_EMAIL

async def admin_email_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return ConversationHandler.END
    text = update.message.text.strip()
    if not text.lower().endswith("@gmail.com"):
        await update.message.reply_text("That‚Äôs not a Gmail address.")
        return ADMIN_EMAIL
    context.user_data["admin_mail"] = text
    kb = InlineKeyboardMarkup.from_row([
        InlineKeyboardButton("How to get app password", url="https://telegra.ph/How-to-get-my-App-Password-05-29"),
        InlineKeyboardButton("Wrong mail", callback_data="cfg_start"),
    ])
    await update.message.reply_text("Now send me your app password.", reply_markup=kb)
    return ADMIN_PASS

async def admin_pass_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return ConversationHandler.END
    pwd = update.message.text.strip()
    mail = context.user_data["admin_mail"]
    temp = await update.message.reply_text("Connecting to your IMAP‚Ä¶")
    if not await test_imap(mail, pwd):
        return await safe_edit_message(temp, "Failed to connect; please retry.")
    data = load_db()
    data["credentials"][0]["mail"] = mail
    data["credentials"][0]["pass"] = pwd
    save_db(data)
    kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Commands", url="https://telegra.ph/Netflix-Bot-Help-Menu-05-31"))
    await safe_edit_message(temp, "Successfully connected.")
    await update.message.reply_text("All set!", reply_markup=kb)
    return ConversationHandler.END

async def approve(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("Not authorized.")
    try:
        _, chat_id_s, days_s = update.message.text.split()
        chat_id, days = int(chat_id_s), int(days_s)
    except:
        return await update.message.reply_text("Usage: /approve <chat_id> <days>")
    data = load_db()
    users = data["credentials"][0]["users"]
    usr = next((u for u in users if u["id"] == chat_id), None)
    if usr:
        if usr["days"] > 0:
            return await update.message.reply_text(f"{chat_id} already approved for {usr['days']} days.")
        usr["days"] = days
        usr.setdefault("mails", [])
    else:
        users.append({"id": chat_id, "days": days, "household": True, "signin": False, "reset": False, "mails": []})
    save_db(data)
    mail_choice_markup = build_mail_choice_markup(chat_id, days)
    await update.message.reply_text(f"Approved {chat_id} for {days} days.", reply_markup=mail_choice_markup)

async def handle_set_all_mails_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, chat_id_str = update.callback_query.data.split(":",1)
    chat_id = int(chat_id_str)
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if not usr:
        return await update.callback_query.message.reply_text("User not found.")
    usr["mails"] = ["ALL"]
    save_db(data)
    markup = build_access_markup(chat_id)
    await update.callback_query.message.reply_text(f"Approved {chat_id} for {usr['days']} days for all mails.", reply_markup=markup)

async def handle_set_specified_mails_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, chat_id_str = update.callback_query.data.split(":", 1)
    chat_id = int(chat_id_str)
    context.user_data[MAIL_FLOW_FLAG] = chat_id
    kb = InlineKeyboardMarkup.from_button(
        InlineKeyboardButton("Go Back ‚èé", callback_data=f"cancel_specify:{chat_id}")
    )
    await update.callback_query.message.reply_text(
        "Send mails to set mails (one per line). Invalid lines ignored.\n\n"
        "Example:\n"
        "`example@gmail.com`\n"
        "`exampl@domain.in`\n"
        "`exampl@anything.in`",
        reply_markup=kb,
        parse_mode="Markdown"
    )

async def handle_cancel_specify_mails(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, chat_id_str = update.callback_query.data.split(":",1)
    chat_id = int(chat_id_str)
    days = next((u["days"] for u in load_db()["credentials"][0]["users"] if u["id"] == chat_id), 0)
    mail_choice_markup = build_mail_choice_markup(chat_id, days)
    await update.callback_query.message.reply_text(f"Approved {chat_id} for {days} days.", reply_markup=mail_choice_markup)
    context.user_data.pop(MAIL_FLOW_FLAG, None)

async def extend(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("Not authorized.")
    try:
        _, chat_id_s, days_s = update.message.text.split()
        chat_id, days = int(chat_id_s), int(days_s)
    except:
        return await update.message.reply_text("Usage: /extend <chat_id> <days>")
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if not usr:
        return await update.message.reply_text(f"{chat_id} is not approved.")
    usr["days"] += days
    usr.setdefault("mails", [])
    save_db(data)
    markup = build_access_markup(chat_id)
    await update.message.reply_text(f"Extended {chat_id}: now {usr['days']} days left.\nThis user has access to:", reply_markup=markup)

async def disapprove(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("Not authorized.")
    try:
        _, chat_id_s = update.message.text.split()
        chat_id = int(chat_id_s)
    except:
        return await update.message.reply_text("Usage: /disapprove <chat_id>")
    data = load_db()
    new = [u for u in data["credentials"][0]["users"] if u["id"] != chat_id]
    if len(new) == len(data["credentials"][0]["users"]):
        return await update.message.reply_text(f"{chat_id} is not approved.")
    data["credentials"][0]["users"] = new
    save_db(data)
    await update.message.reply_text(f"Removed approval for {chat_id}.")

async def toggle_feature_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    action, chat_id_str = update.callback_query.data.split(":",1)
    chat_id = int(chat_id_str)
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    if action == "disapprove_cb":
        data["credentials"][0]["users"] = [u for u in data["credentials"][0]["users"] if u["id"] != chat_id]
        save_db(data)
        await safe_edit_message(update.callback_query.message, f"User {chat_id} disapproved.")
        return
    if not usr:
        return await update.callback_query.answer("User not found.")
    if action == "toggle_household":
        usr["household"] = not usr['household']
    elif action == "toggle_signin":
        usr["signin"] = not usr['signin']
    elif action == "toggle_reset":
        usr["reset"] = not usr['reset']
    save_db(data)
    markup = build_access_markup(chat_id)
    await safe_edit_message(update.callback_query.message, f"Access settings for {chat_id}:", reply_markup=markup)

async def info_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return await update.message.reply_text("You are not authorized.")
    if not context.args:
        return await update.message.reply_text("Usage: /info <email>")
    email_arg = context.args[0].strip().lower()
    data = load_db()
    linked = [
        u["id"]
        for u in data["credentials"][0]["users"]
        if u.get("mails") == ["ALL"]
           or email_arg in [m.lower() for m in u.get("mails",[])]
    ]
    if not linked:
        return await update.message.reply_text(f"{email_arg} is not linked to any user.")
    result = {email_arg: linked}
    bio = BytesIO(json.dumps(result, indent=2).encode("utf-8"))
    bio.name = f"{email_arg.replace('@','_at_')}.json"
    kb = InlineKeyboardMarkup.from_column([
        InlineKeyboardButton("Unlink all users linked to this email", callback_data=f"unlink_all_email:{email_arg}"),
        InlineKeyboardButton("Go Back", callback_data="info_go_back")
    ])
    await context.bot.send_document(
        chat_id=ADMIN_CHAT_ID,
        document=bio,
        filename=bio.name,
        caption=f"{email_arg} is linked with {len(linked)} user(s); open JSON to see them.",
        reply_markup=kb
    )

async def handle_unlink_all_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, email_arg = update.callback_query.data.split(":", 1)
    email_arg = email_arg.lower()
    data = load_db()
    changed = False
    for u in data["credentials"][0]["users"]:
        if u.get("mails") != ["ALL"]:
            before = len(u["mails"])
            u["mails"] = [m for m in u["mails"] if m.lower() != email_arg]
            if len(u["mails"]) != before:
                changed = True
    if changed:
        save_db(data)
        await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=f"‚úÖ Unlinked {email_arg} from all users.")
    else:
        await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=f"‚ÑπÔ∏è No user had {email_arg} linked.")

async def handle_info_go_back(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    await update.callback_query.message.reply_text("Cancelled.")

async def handle_see_specified_mails(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    _, chat_id_str = update.callback_query.data.split(":", 1)
    chat_id = int(chat_id_str)
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
    mails = usr.get("mails", [])
    bio = BytesIO(json.dumps({str(chat_id): mails}, indent=2).encode("utf-8"))
    bio.name = f"{chat_id}.json"
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("Unlink mails linked to this user", callback_data=f"unlink_mail_user_cb:{chat_id}")],
        [InlineKeyboardButton("Link new mails to this user",      callback_data=f"link_mail_user_cb:{chat_id}")],
        [InlineKeyboardButton("Cancel",                            callback_data="cancel_cb")],
    ])
    await context.bot.send_document(
        chat_id=ADMIN_CHAT_ID,
        document=bio,
        filename=bio.name,
        caption=f"User {chat_id} is linked with these mails:",
        reply_markup=kb
    )

async def cancel_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text="Operation cancelled.")

async def unlink_mail_user_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    _, chat_id_str = update.callback_query.data.split(":", 1)
    context.user_data["unlink_for"] = int(chat_id_str)
    await update.callback_query.message.reply_text("Send the mails to unlink (one per line):")

async def link_mail_user_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    _, chat_id_str = update.callback_query.data.split(":", 1)
    context.user_data["link_for"] = int(chat_id_str)
    await update.callback_query.message.reply_text("Send the mails to link (one per line):")

async def handle_fh(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Admins not allowed to fetch
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return await update.callback_query.answer("Admins cannot fetch Netflix mails.")
    await update.callback_query.answer()
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("Go Back ‚èé", callback_data="go_back")]])
    # Use safe edit because the button's message might be unchanged
    await safe_edit_message(update.callback_query.message, f"Okay {update.effective_user.full_name}, send me your Netflix email to retrieve household mail.", reply_markup=kb)
    context.user_data[F_FLOW_FLAG] = "fh"

async def handle_fs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return await update.callback_query.answer("Admins cannot fetch Netflix mails.")
    await update.callback_query.answer()
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("Go Back ‚èé", callback_data="go_back")]])
    await safe_edit_message(update.callback_query.message, f"Okay {update.effective_user.full_name}, send me your Netflix email to retrieve sign-in code.", reply_markup=kb)
    context.user_data[F_FLOW_FLAG] = "fs"

async def handle_fr(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return await update.callback_query.answer("Admins cannot fetch Netflix mails.")
    await update.callback_query.answer()
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("Go Back ‚èé", callback_data="go_back")]])
    # This was failing with "Message is not modified" ‚Äî safe_edit_message will handle that
    await safe_edit_message(update.callback_query.message, f"Okay {update.effective_user.full_name}, send me your Netflix email to retrieve password reset link.", reply_markup=kb)
    context.user_data[F_FLOW_FLAG] = "fr"

async def handle_go_back(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return await update.callback_query.answer("Admins cannot fetch Netflix mails.")
    await update.callback_query.answer()
    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"]==update.effective_user.id), None)
    if not usr:
        return
    buttons = []
    if usr.get("household"):
        buttons.append(InlineKeyboardButton("Household Mail üìç", callback_data="fh"))
    if usr.get("signin"):
        buttons.append(InlineKeyboardButton("Sign-in Code üîë", callback_data="fs"))
    if usr.get("reset"):
        buttons.append(InlineKeyboardButton("Password Reset üõ°Ô∏è", callback_data="fr"))
    if not buttons:
        await safe_edit_message(update.callback_query.message, f"Hey {update.effective_user.full_name}, you have no features enabled.")
        context.user_data.pop(F_FLOW_FLAG, None)
        return
    kb = InlineKeyboardMarkup.from_row(buttons)
    await safe_edit_message(update.callback_query.message, f"Hey {update.effective_user.full_name}, which Netflix mail would you like to retrieve?", reply_markup=kb)
    context.user_data.pop(F_FLOW_FLAG, None)

async def handle_flow_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id == ADMIN_CHAT_ID:
        return
    if MAIL_FLOW_FLAG in context.user_data:
        # admin message flow handling uses same handler; ignore here
        return

    flow = context.user_data.pop(F_FLOW_FLAG, None)
    if not flow:
        return await update.message.reply_text("Unrecognized message. To retrieve Netflix mail, send /fetch")

    email_addr = update.message.text.strip()
    if not re.match(r"^[^@\s]+@[^@\s]+\.[^@\s]+$", email_addr):
        return await update.message.reply_text("Please send a valid email address, or send /fetch to start over.")

    data = load_db()
    usr = next((u for u in data["credentials"][0]["users"] if u["id"] == update.effective_chat.id), None)
    allowed = usr.get("mails", [])

    if not allowed:
        return await update.message.reply_text(
            "‚ùå You don‚Äôt have access to any Netflix accounts. "
            "Please ask your admin to grant you mail permissions."
        )

    if allowed != ["ALL"] and email_addr.lower() not in [m.lower() for m in allowed]:
        return await update.message.reply_text(
            f"‚ùå You‚Äôre not authorized to fetch mail for {email_addr}.\n"
            f"Allowed addresses: {', '.join(allowed)}"
        )

    temp = await update.message.reply_text(
        f"Fetching Netflix {'household mail' if flow=='fh' else 'sign-in code' if flow=='fs' else 'password reset link'} for {email_addr}..."
    )

    mail, pwd = data["credentials"][0]["mail"], data["credentials"][0]["pass"]
    loop = asyncio.get_event_loop()
    imap_conn = None

    feature = "unknown"

    try:
        imap_conn = await loop.run_in_executor(None, lambda: _connect_to_gmail(mail, pwd))
        uids_hour = await loop.run_in_executor(None, lambda: _search_last_hour(imap_conn, email_addr))
        if not uids_hour:
            return await safe_edit_message(temp, f"No Netflix emails in the last hour for {email_addr}.")
        uids_15m = await loop.run_in_executor(None, lambda: _filter_uids_last_15m(imap_conn, uids_hour))
        if not uids_15m:
            return await safe_edit_message(temp, f"No Netflix emails in the last 15 minutes for {email_addr}.")

        if flow == "fh":
            results = await loop.run_in_executor(None, lambda: _extract_household_links(imap_conn, uids_15m))
            links = [l for l in results.values() if l]
            if not links:
                await safe_edit_message(temp, "No household links found in the last 15 minutes.")
            else:
                for link in links:
                    await update.message.reply_text(
                        f"üìß Received from: info@account.netflix.com\n"
                        f"‚û§ Received to: {email_addr}\n"
                        f"üîó Household link: {link}"
                    )
                await temp.delete()
            feature = "household link"

        elif flow == "fs":
            results = await loop.run_in_executor(None, lambda: _extract_signin_codes(imap_conn, uids_15m))
            codes = [c for c in results.values() if c]
            if not codes:
                await safe_edit_message(temp, "No sign-in codes found in the last 15 minutes.")
            else:
                for code in codes:
                    await update.message.reply_text(
                        f"üìß Received from: info@account.netflix.com\n"
                        f"‚û§ Received to: <code>{email_addr}</code>\n"
                        f"üîë Sign-in code: <code>{code}</code>",
                        parse_mode="HTML"
                    )
                await temp.delete()
            feature = "sign-in code"

        else:
            results = await loop.run_in_executor(None, lambda: _extract_reset_links(imap_conn, uids_15m))
            links = [l for l in results.values() if l]
            if not links:
                await safe_edit_message(temp, "No password reset links found in the last 15 minutes.")
            else:
                for link in links:
                    await update.message.reply_text(
                        f"üìß Received from: info@account.netflix.com\n"
                        f"‚û§ Received to: {email_addr}\n"
                        f"üõ°Ô∏è Reset link: {link}"
                    )
                await temp.delete()
            feature = "password reset link"

    except Exception as e:
        logger.exception("Error during IMAP fetch")
        await update.message.reply_text("Error occurred while fetching emails.")
    finally:
        if imap_conn:
            try:
                await loop.run_in_executor(None, lambda: imap_conn.logout())
            except Exception:
                pass

    # Notify admin about the successful request (best-effort)
    try:
        user = update.effective_user
        mention = f"[{user.id}](tg://user?id={user.id})"
        fullname = user.full_name
        uname = f"@{escape_md(user.username)}" if user.username else ""
        lines = ["Alert üö®", mention, fullname]
        if uname:
            lines.append(uname)
        lines.append(f"this user requested {feature} and it was sent successfully.")
        lines.append(f"mail: {email_addr}")
        alert_text = "\n".join(lines)
        kb = InlineKeyboardMarkup.from_button(InlineKeyboardButton("Disapprove this user", callback_data=f"disapprove_cb:{user.id}"))
        await context.bot.send_message(ADMIN_CHAT_ID, alert_text, parse_mode="Markdown", reply_markup=kb)
    except Exception:
        logger.debug("Failed to send admin alert after fetch", exc_info=True)

async def handle_admin_mail_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    if MAIL_FLOW_FLAG in context.user_data:
        chat_id = context.user_data.pop(MAIL_FLOW_FLAG)
        lines = [l.strip() for l in update.message.text.splitlines()]
        valid, invalid = [], []
        email_re = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")
        for l in lines:
            if email_re.match(l):
                valid.append(l)
            elif l:
                invalid.append(l)
        if not valid:
            return await update.message.reply_text("No valid email addresses detected. Please send valid emails one per line.")
        data = load_db()
        usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
        if not usr:
            return await update.message.reply_text("User not found.")
        usr["mails"] = valid
        save_db(data)
        markup = build_access_markup(chat_id)
        msg = f"Approved {chat_id} for {usr['days']} days for specified mails."
        if invalid:
            msg += f"\nIgnored invalid lines: {', '.join(invalid)}"
        return await update.message.reply_text(msg, reply_markup=markup)
    if "unlink_for" in context.user_data:
        chat_id = context.user_data.pop("unlink_for")
        lines = [l.strip() for l in update.message.text.splitlines() if l.strip()]
        data = load_db()
        usr = next((u for u in data["credentials"][0]["users"] if u["id"] == chat_id), None)
        removed, skipped = [], []
        for mail in lines:
            if usr and mail in usr.get("mails", []):
                usr["mails"].remove(mail)
                removed.append(mail)
            else:
                skipped.append(mail)
        save_db(data)
        return await update.message.reply_text(f"Unlinked: {removed}\nSkipped: {skipped}")
    if "link_for" in context.user_data:
        chat_id = context.user_data.pop("link_for")
        lines = [l.strip() for l in update.message.text.splitlines() if l.strip()]
        email_re = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")
       
